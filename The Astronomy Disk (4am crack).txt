-----------The Astronomy Disk----------A 4am crack                  2015-10-24---------------------------------------Name: The Astronomy DiskGenre: educationalYear: 1984Authors: Sheridan A. SimonPublisher: Prentice-Hall, Inc.Media: single-sided 5.25-inch floppyOS: DOS 3.3 with custom bootloaderPrevious cracks: none                   ~               Chapter 0 In Which Various Automated Tools Fail          In Interesting WaysCOPYA  immediate disk read errorLocksmith Fast Disk Backup  unable to read any trackEDD 4 bit copy (no sync, no count)  no read errors, but the copy just  grinds and crashesCopy ][+ nibble editor  the nibbles are pretty noisy (the  sync bytes between sectors are not  a pretty pattern of $FF), but the  nibble editor is pretty sure this is  a 16-sector disk with modified  prologues and epilogues                 --v--   COPY ][ PLUS BIT COPY PROGRAM 8.4(C) 1982-9 CENTRAL POINT SOFTWARE, INC.---------------------------------------TRACK: 03  START: 22FF  LENGTH: 18522460: D3 B3 AF CE D3 D3 D3 D3   VIEW2468: D3 D3 D3 D3 D3 F4 96 962470: 96 96 ED AA EB FF FF FF            ^^^^^^^^         data epilogue2478: 95 FF F4 EB AF ED FF DB2480: B7 AD BF D7 AB AA D5 AB  <-2485                     ^^^^^^^^                 address prologue2488: FF FE AB AB AA AB FE FE      ^^^^^ ^^^^^ ^^^^^ ^^^^^       vol   trk   sec  chksm2490: DE AB EE EE EE B5 CF E5      ^^^^^ address epilogue2498: E9 D6 AF ED FF DB AA D5                        ^^^^^                    data prologue24A0: EB D9 DF AD B7 B7 ED BF      ^^---------------------------------------  A  TO ANALYZE DATA  ESC TO QUIT  ?  FOR HELP SCREEN  /  CHANGE PARMS  Q  FOR NEXT TRACK   SPACE TO RE-READ                 --^--Disk Fixer  T00,S00 is readable, but nothing else    on track $00  ["O" -> "Input/Output Control"]    set Address Prologue to "AA D5 AB"    set Address Epilogue to "DE AB EB"    set Data Prologue to "AA D5 EB"    set Data Epilogue to "ED AA EB"  T01+ readable!  T01-T02 -> full DOS 3.3  T11 -> DOS 3.3 catalog  T01,S0D -> startup program is "HELLO"Why didn't COPYA work?  modified prologues (every track)Why didn't Locksmith FDB work?  modified prologues (every track)Next steps:  1. Trace the boot to capture the RWTS  2. Advanced Demuffin to convert the     disk to a standard format  3. Replace tracks $00-$02 with a     standard copy of DOS 3.3  4. Declare victory(*)(*) take a nap                   ~               Chapter 1    In Which We Can Do This All Day[S6,D1=original disk][S5,D1=my work disk]]PR#5...]CALL -151*9600<C600.C6FFM; copy boot0 to higher memory so it; survives a reboot96F8-   A0 00       LDY   #$0096FA-   B9 00 08    LDA   $0800,Y96FD-   99 00 28    STA   $2800,Y9700-   C8          INY9701-   D0 F7       BNE   $96FA; turn off slot 6 drive motor9703-   AD E8 C0    LDA   $C0E8; immediately reboot to my work disk9706-   4C 00 C5    JMP   $C500*BSAVE TRACE,A$9600,L$109*9600G...reboots slot 6......reboots slot 5...]BSAVE BOOT0,A$2800,L$100]CALL -151*800<2800.28FFM*8000800- 01*801L0801-   A2 00       LDX   #$000803-   BD 00 08    LDA   $0800,X0806-   9D 00 02    STA   $0200,X0809-   E8          INX080A-   D0 F7       BNE   $0803080C-   4C 0F 02    JMP   $020FHmm. Moving boot0 to the input buffer.I've seen this technique before, but Ihave not seen this exact code. We'llneed to trace it manually.*200<800.8FFM*20FL; save text page020F-   BD 00 04    LDA   $0400,X0212-   9D 00 20    STA   $2000,X0215-   BD 00 05    LDA   $0500,X0218-   9D 00 21    STA   $2100,X021B-   BD 00 06    LDA   $0600,X021E-   9D 00 22    STA   $2200,X0221-   BD 00 07    LDA   $0700,X0224-   9D 00 23    STA   $2300,X0227-   E8          INX0228-   D0 E5       BNE   $020F; wipe text page 2022A-   A9 A0       LDA   #$A0022C-   9D 00 08    STA   $0800,X022F-   9D 00 09    STA   $0900,X0232-   9D 00 0A    STA   $0A00,X0235-   9D 00 0B    STA   $0B00,X0238-   E8          INX0239-   D0 F1       BNE   $022C; show text page 2 (now blank)023B-   AD 55 C0    LDA   $C055; set up zero page for a PROM read of; another sector023E-   A9 00       LDA   #$000240-   85 26       STA   $260242-   85 41       STA   $410244-   A9 0D       LDA   #$0D0246-   85 3D       STA   $3D0248-   A9 04       LDA   #$04024A-   85 27       STA   $27024C-   A6 2B       LDX   $2B; but we're not actually calling PROM,; we're calling our own routine that; reads a single sector with modified; prologues024E-   20 54 02    JSR   $0254; jump to the sector we just read0251-   4C 00 04    JMP   $0400The custom read routine starts at $254:; find "AA D5 AB" address prologue0254-   BD 8C C0    LDA   $C08C,X0257-   10 FB       BPL   $02540259-   49 AA       EOR   #$AA025B-   D0 F7       BNE   $0254025D-   BD 8C C0    LDA   $C08C,X0260-   10 FB       BPL   $025D0262-   C9 D5       CMP   #$D50264-   D0 F3       BNE   $02590266-   EA          NOP0267-   BD 8C C0    LDA   $C08C,X026A-   10 FB       BPL   $0267026C-   C9 AB       CMP   #$AB026E-   F0 02       BEQ   $02720270-   D0 E2       BNE   $0254; parse address field0272-   A0 03       LDY   #$030274-   85 40       STA   $400276-   BD 8C C0    LDA   $C08C,X0279-   10 FB       BPL   $0276027B-   2A          ROL027C-   85 3C       STA   $3C027E-   BD 8C C0    LDA   $C08C,X0281-   10 FB       BPL   $027E0283-   25 3C       AND   $3C0285-   88          DEY0286-   D0 EC       BNE   $0274; match sector0288-   C5 3D       CMP   $3D028A-   D0 C8       BNE   $0254; match track028C-   A5 40       LDA   $40028E-   C5 41       CMP   $410290-   D0 C2       BNE   $0254; find "AA D5 EB" data prologue0292-   BD 8C C0    LDA   $C08C,X0295-   10 FB       BPL   $02920297-   49 AA       EOR   #$AA0299-   D0 F7       BNE   $0292029B-   BD 8C C0    LDA   $C08C,X029E-   10 FB       BPL   $029B02A0-   C9 D5       CMP   #$D502A2-   D0 F3       BNE   $029702A4-   EA          NOP02A5-   BD 8C C0    LDA   $C08C,X02A8-   10 FB       BPL   $02A502AA-   49 EB       EOR   #$EB02AC-   F0 02       BEQ   $02B002AE-   D0 E2       BNE   $0292.. &c. (standard 6-and-2 decoding).I can interrupt the boot at $0251(instead of jumping to $0400).*9600<C600.C6FFM; reproduce initial copy of boot0 code96F8-   A2 00       LDX   #$0096FA-   BD 00 08    LDA   $0800,X96FD-   9D 00 02    STA   $0200,X9700-   E8          INX9701-   D0 F7       BNE   $96FA; set up callback instead of jumping to; $04009703-   A9 10       LDA   #$109705-   8D 52 02    STA   $02529708-   A9 97       LDA   #$97970A-   8D 53 02    STA   $0253; start the boot970D-   4C 0F 02    JMP   $020F; callback is here --; copy sector we read into $0400 to the; graphics page so it survives a reboot9710-   A0 00       LDY   #$009712-   B9 00 04    LDA   $0400,Y9715-   99 00 24    STA   $2400,Y9718-   C8          INY9719-   D0 F7       BNE   $9712; turn off slot 6 drive motor971B-   AD E8 C0    LDA   $C0E8; reboot to my work disk971E-   4C 00 C5    JMP   $C500*BSAVE TRACE2,A$9600,L$121*9600G...reboots slot 6......reboots slot 5...]BSAVE BOOT1 0400-04FF,A$2400,L$100]CALL -151I'm going to leave this code at $2400,since $0400 is part of the text page.Relative branches will look correct,but absolute addresses will be +$2000.*2400L; set up for another sector read2400-   A9 00       LDA   #$002402-   85 26       STA   $262404-   85 41       STA   $412406-   A9 0B       LDA   #$0B2408-   85 3D       STA   $3D240A-   A9 05       LDA   #$05240C-   85 27       STA   $27240E-   A6 2B       LDX   $2B; use the same custom disk read routine; as boot0 (still in low memory)2410-   20 54 02    JSR   $0254; and jump there2413-   4C 00 05    JMP   $0500Let's interrupt the boot (again) to seewhat's at $0500. I can do this all day.I am not that busy.*9600<C600.C6FFM; copy boot0 (save as previous trace)96F8-   A2 00       LDX   #$0096FA-   BD 00 08    LDA   $0800,X96FD-   9D 00 02    STA   $0200,X9700-   E8          INX9701-   D0 F7       BNE   $96FA; set up callback #1 after loading $4009703-   A9 10       LDA   #$109705-   8D 52 02    STA   $02529708-   A9 97       LDA   #$97970A-   8D 53 02    STA   $0253; start the boot970D-   4C 0F 02    JMP   $020F; callback #1 is here --; set up callback #2 after loading $5009710-   A9 1D       LDA   #$1D9712-   8D 14 04    STA   $04149715-   A9 97       LDA   #$979717-   8D 15 04    STA   $0415; continue the boot971A-   4C 00 04    JMP   $0400; callback #2 is here --; copy the sector we read at $0500 to; the graphics page so it survives a; reboot971D-   A0 00       LDY   #$00971F-   B9 00 05    LDA   $0500,Y9722-   99 00 25    STA   $2500,Y9725-   C8          INY9726-   D0 F7       BNE   $971F; turn off drive and reboot9728-   AD E8 C0    LDA   $C0E8972B-   4C 00 C5    JMP   $C500*BSAVE TRACE3,A$9600,L$12E*9600G...reboots slot 6......reboots slot 5...]BSAVE BOOT1 0500-05FF,A$2500,L$100]CALL -151*2500L2500-   A9 00       LDA   #$002502-   85 26       STA   $262504-   85 41       STA   $412506-   A9 09       LDA   #$092508-   85 3D       STA   $3D250A-   A9 06       LDA   #$06250C-   85 27       STA   $27250E-   A6 2B       LDX   $2B2510-   20 54 02    JSR   $02542513-   4C 00 06    JMP   $0600COME AT ME, BRO!*9600<C600.C6FFM.. [same as previous traces].; callback #2 is here --; set up callback #3 (!)971D-   A9 2A       LDA   #$2A971F-   8D 14 05    STA   $05149722-   A9 97       LDA   #$979724-   8D 15 05    STA   $0515; continue the boot9727-   4C 00 05    JMP   $0500; callback #3 is here --; save $0600 and reboot972A-   A0 00       LDY   #$00972C-   B9 00 06    LDA   $0600,Y972F-   99 00 26    STA   $2600,Y9732-   C8          INY9733-   D0 F7       BNE   $972C9735-   AD E8 C0    LDA   $C0E89738-   4C 00 C5    JMP   $C500*BSAVE TRACE4,A$9600,L$13B*9600G...blah blah blah...]BSAVE BOOT1 0600-06FF,A$2600,L$100]CALL -151*2600L; set up a data table of some sort2600-   A9 B6       LDA   #$B62602-   A0 06       LDY   #$062604-   BE C0 05    LDX   $05C0,Y2607-   9D E4 06    STA   $06E4,X260A-   18          CLC260B-   69 01       ADC   #$01260D-   C8          INY260E-   C0 10       CPY   #$102610-   D0 F2       BNE   $2604; You get an RWTS, and YOU get an RWTS,; and EVERYBODY GETS AN RWTS2612-   A6 2B       LDX   $2B2614-   BD 8C C0    LDA   $C08C,X2617-   10 FB       BPL   $2614; still the same prologue ("AA D5 AB")2619-   49 AA       EOR   #$AA261B-   D0 F7       BNE   $2614261D-   BD 8C C0    LDA   $C08C,X2620-   10 FB       BPL   $261D2622-   C9 D5       CMP   #$D52624-   D0 F3       BNE   $26192626-   EA          NOP2627-   BD 8C C0    LDA   $C08C,X262A-   10 FB       BPL   $2627262C-   C9 AB       CMP   #$AB262E-   D0 E4       BNE   $2614; parse address field2630-   A0 03       LDY   #$032632-   85 40       STA   $402634-   BD 8C C0    LDA   $C08C,X2637-   10 FB       BPL   $26342639-   2A          ROL263A-   85 3C       STA   $3C263C-   BD 8C C0    LDA   $C08C,X263F-   10 FB       BPL   $263C2641-   25 3C       AND   $3C2643-   88          DEY2644-   D0 EC       BNE   $26322646-   85 3D       STA   $3D; check the data table we created; earlier to see if if we care about; this sector2648-   A4 3D       LDY   $3D264A-   B9 E4 06    LDA   $06E4,Y; nope, branch back and keep looking264D-   F0 C3       BEQ   $2612; yes, keep going (and use the value; from the table as the address)264F-   85 27       STA   $27The data table was filled starting with$B6 (A=$B6 at $0600) up to $BF (Y=$06at $0602 and up to but not including$10 at $060E). So I'm guessing we'rereading into $B600..$BFFF.; same data prologue, "AA D5 EB"2651-   BD 8C C0    LDA   $C08C,X2654-   10 FB       BPL   $26512656-   49 AA       EOR   #$AA2658-   D0 F7       BNE   $2651265A-   BD 8C C0    LDA   $C08C,X265D-   10 FB       BPL   $265A265F-   C9 D5       CMP   #$D52661-   D0 F3       BNE   $26562663-   EA          NOP2664-   BD 8C C0    LDA   $C08C,X2667-   10 FB       BPL   $26642669-   49 EB       EOR   #$EB266B-   D0 E4       BNE   $2651.. &c. (standard 6-and-2 decoding).; mark that we read this sector26B5-   A4 3D       LDY   $3D26B7-   A9 00       LDA   #$0026B9-   99 E4 06    STA   $06E4,Y; check whether we've read every sector; that we care about26BC-   A0 0F       LDY   #$0F26BE-   B9 E4 06    LDA   $06E4,Y26C1-   F0 03       BEQ   $26C6; no, jump back to read more26C3-   4C 12 06    JMP   $061226C6-   88          DEY26C7-   10 F5       BPL   $26BE; If we fall through here, we've read; all the sectors we care about. Now; move some memory around26C9-   A2 00       LDX   #$0026CB-   BD 00 05    LDA   $0500,X26CE-   9D 00 03    STA   $0300,X26D1-   E8          INX26D2-   D0 F7       BNE   $26CB; twice, in case it didn't take the; first time (WTF)26D4-   A2 00       LDX   #$0026D6-   BD 00 05    LDA   $0500,X26D9-   9D 00 03    STA   $0300,X26DC-   E8          INX26DD-   D0 F7       BNE   $26D626DF-   A6 2B       LDX   $2B; and continue elsewhere26E1-   4C 00 B7    JMP   $B700And now this is starting to look likewe're making progress towards someordinary DOS 3.3 boot1 code. Maybe. Nopromises, though.                   ~               Chapter 2     My God, It's Full Of Stars(*)(*) Kevin insisted that I use this line    at least once. Hi Kevin!*9600<C600.C6FFM*96F8L; reproduce initial copy of boot0 code96F8-   A2 00       LDX   #$0096FA-   BD 00 08    LDA   $0800,X96FD-   9D 00 02    STA   $0200,X9700-   E8          INX9701-   D0 F7       BNE   $96FA; set up callback #1 instead of jumping; to $04009703-   A9 10       LDA   #$109705-   8D 52 02    STA   $02529708-   A9 97       LDA   #$97970A-   8D 53 02    STA   $0253; start the boot970D-   4C 0F 02    JMP   $020F; callback #1 is here --; set up callback #29710-   A9 1D       LDA   #$1D9712-   8D 14 04    STA   $04149715-   A9 97       LDA   #$979717-   8D 15 04    STA   $0415; continue the boot971A-   4C 00 04    JMP   $0400; callback #2 is here --; set up callback #3971D-   A9 2A       LDA   #$2A971F-   8D 14 05    STA   $05149722-   A9 97       LDA   #$979724-   8D 15 05    STA   $0515; continue the boot9727-   4C 00 05    JMP   $0500; callback #3 is here --; set up callback #4972A-   A9 37       LDA   #$37972C-   8D E2 06    STA   $06E2972F-   A9 97       LDA   #$979731-   8D E3 06    STA   $06E3; continue the boot9734-   4C 00 06    JMP   $0600; callback #4 is here --; copy next phase into graphics page; so it survives a reboot9737-   A2 0A       LDX   #$0A9739-   A0 00       LDY   #$00973B-   B9 00 B6    LDA   $B600,Y973E-   99 00 26    STA   $2600,Y9741-   C8          INY9742-   D0 F7       BNE   $973B9744-   EE 3D 97    INC   $973D9747-   EE 40 97    INC   $9740974A-   CA          DEX974B-   D0 EE       BNE   $973B; turn off the slot 6 drive motor and; reboot to my work disk974D-   AD E8 C0    LDA   $C0E89750-   4C 00 C5    JMP   $C500*BSAVE TRACE5,A$9600,L$153*9600G...reboots slot 6......reboots slot 5...]BSAVE BOOT1 B600-BFFF,A$2600,L$A00]CALL -151*FE89G FE93G     ; disconnect DOS*B600<2600.2FFFM ; move RWTS into place*B700LB700-   4C EA B6    JMP   $B6EA*B6EALB6EA-   A9 80       LDA   #$80B6EC-   85 D8       STA   $D8; put boot slot (x16) into... an RWTS; parameter table?B6EE-   8E E9 B7    STX   $B7E9B6F1-   8E F7 B7    STX   $B7F7B6F4-   20 B3 B6    JSR   $B6B3*B6B3L; overwrite previous boot code with the; text page we saved way back at $020FB6B3-   A0 00       LDY   #$00B6B5-   B9 00 20    LDA   $2000,YB6B8-   99 00 04    STA   $0400,YB6BB-   B9 00 21    LDA   $2100,YB6BE-   99 00 05    STA   $0500,YB6C1-   B9 00 22    LDA   $2200,YB6C4-   99 00 06    STA   $0600,YB6C7-   C8          INYB6C8-   D0 EB       BNE   $B6B5; and zap it all anyway by calling HOME; (WTF)B6CA-   4C 58 FC    JMP   $FC58Continuing from $B6F7...; back to text page 1 (now blank)B6F7-   AD 54 C0    LDA   $C054B6FA-   AD 10 C0    LDA   $C010B6FD-   4C 06 B7    JMP   $B706*B706L; fairly standard setup of an RWTS; parameter tableB706-   A9 01       LDA   #$01B708-   8D F8 B7    STA   $B7F8B70B-   8D EA B7    STA   $B7EAB70E-   AD E0 B7    LDA   $B7E0B711-   8D E1 B7    STA   $B7E1; start reading on T02,S08 (4 sectors; offset from standard DOS 3.3, which; means it won't need to read anything; from track $00)B714-   A9 02       LDA   #$02B716-   8D EC B7    STA   $B7ECB719-   A9 08       LDA   #$08B71B-   8D ED B7    STA   $B7EDB71E-   AC E7 B7    LDY   $B7E7B721-   88          DEYB722-   8C F1 B7    STY   $B7F1B725-   A9 01       LDA   #$01B727-   8D F4 B7    STA   $B7F4B72A-   8A          TXAB72B-   4A          LSRB72C-   4A          LSRB72D-   4A          LSR; oh what fresh hell is thisB72F-   20 30 B6    JSR   $B630*B630L; munging the boot slot into a reboot; vectorB630-   AA          TAXB631-   09 C0       ORA   #$C0B633-   8D 11 B6    STA   $B611B636-   A9 00       LDA   #$00B638-   60          RTSContinuing from $B732...B732-   9D F8 04    STA   $04F8,XB735-   9D 78 04    STA   $0478,X; load DOSB738-   20 93 B7    JSR   $B793B73B-   A2 FF       LDX   #$FFB73D-   9A          TXSB73E-   8E EB B7    STX   $B7EB; initialize ROM and stuff (normal)B741-   4C C8 BF    JMP   $BFC8B744-   20 89 FE    JSR   $FE89; jump to next phase of DOS to load; the HELLO programB747-   4C 84 9D    JMP   $9D84Poking around a bit further, the RWTSis not laid out in a normal fashion,but the entry point is still at $BD00.(There is also the standard higherlevel entry point at $B7B5, which iscalled by the even higher level entrypoint at $B793.)The RWTS is a weird hybrid that canread both the (protected) program diskand a standard data disk. This is notunusual in educational programs thatlet you load and save your work on yourown disk.For example, here is the code to matchthe data field prologue:*B9CDLB9CD-   BD 8C C0    LDA   $C08C,XB9D0-   10 FB       BPL   $B9CD; just an RTS (so, killing 12 cycles --; 6 to call it and 6 to return)B9D2-   20 59 BA    JSR   $BA59; match $AA or $D5B9D5-   C9 AA       CMP   #$AAB9D7-   F0 04       BEQ   $B9DDB9D9-   C9 D5       CMP   #$D5B9DB-   D0 EA       BNE   $B9C7B9DD-   EA          NOP; match $D5 or $AAB9DE-   BD 8C C0    LDA   $C08C,XB9E1-   10 FB       BPL   $B9DEB9E3-   C9 D5       CMP   #$D5B9E5-   F0 04       BEQ   $B9EBB9E7-   C9 AA       CMP   #$AAB9E9-   D0 EA       BNE   $B9D5B9EB-   A0 56       LDY   #$56; match $EB or $ADB9ED-   BD 8C C0    LDA   $C08C,XB9F0-   10 FB       BPL   $B9EDB9F2-   C9 EB       CMP   #$EBB9F4-   F0 04       BEQ   $B9FAB9F6-   C9 AD       CMP   #$ADB9F8-   D0 DB       BNE   $B9D5So this one RWTS can read the programdisk ("AA D5 EB" prologue) or a normaldata disk ("D5 AA AD" prologue). Nice!And here's the kicker, a bit furtherdown:*BA2AL; for the epilogue, match $DE...BA2A-   BD 8C C0    LDA   $C08C,XBA2D-   10 FB       BPL   $BA2ABA2F-   C9 DE       CMP   #$DEBA31-   F0 1C       BEQ   $BA4F; ...or $ED, followed by a timing bit!BA33-   C9 ED       CMP   #$EDBA35-   D0 21       BNE   $BA58BA37-   20 59 BA    JSR   $BA59BA3A-   EA          NOPBA3B-   EA          NOPBA3C-   EA          NOPBA3D-   BD 8C C0    LDA   $C08C,XBA40-   30 16       BMI   $BA58BA42-   EA          NOPBA43-   BD 8C C0    LDA   $C08C,XBA46-   10 FB       BPL   $BA43BA48-   C9 AA       CMP   #$AABA4A-   D0 0C       BNE   $BA58BA4C-   4C 5A BA    JMP   $BA5ABA4F-   BD 8C C0    LDA   $C08C,XBA52-   10 FB       BPL   $BA4FBA54-   C9 AA       CMP   #$AABA56-   F0 02       BEQ   $BA5ABA58-   38          SECBA59-   60          RTSBA5A-   18          CLCBA5B-   60          RTSThis explains why my EDD bit copy wouldjust grind. It wasn't preserving theextra timing bit after the first nibbleof the data epilogue, so the RWTS couldnever find the epilogue. (Specifically,the RWTS intentionally wastes enoughtime between $BA37 and $BA3C that the$ED nibble on the copy has fallen outof the data latch, so the extra checkat $BA3D fails and it jumps to $BA58 toset the carry, indicating a read error.On the original disk, the extra timingbit ensures that the data latch holdsonto the $ED nibble for 4 extra cycles,so the branch at $BA40 is not taken andit falls through to check the secondepilogue nibble at $BA43.)The good news: this RWTS is just barelynormal enough to plug it into AdvancedDemuffin and convert the disk sector bysector (starting from track $01).The bad news: there isn't any bad news.This was the wrong format to use toannounce the good news.                   ~               Chapter 3 In Which We Finally Use The Original    Disk As A Weapon Against Itself        And It Goes Splendidly*C500G       ; because we overwrote DOS...]BRUN ADVANCED DEMUFFIN 1.5["5" to switch to slot 5]["R" to load a new RWTS module]  --> At $B6, load "BOOT1 B600-BFFF"      from drive 1["6" to switch to slot 6]["C" to convert disk]--> CHANGE DEFAULT VALUES? YADVANCED DEMUFFIN 1.5    (C) 1983, 2014ORIGINAL BY THE STACK    UPDATES BY 4AM=======================================INPUT ALL VALUES IN HEXSECTORS PER TRACK? (13/16) 16START TRACK: $01        <-- change thisSTART SECTOR: $00END TRACK: $22END SECTOR: $0FINCREMENT: 1MAX # OF RETRIES: 0COPY FROM DRIVE 1TO DRIVE: 2=======================================16SC $01,$00-$22,$0F BY1.0 S6,D1->S6,D2Now press RETURN to start the copy...                 --v--ADVANCED DEMUFFIN 1.5    (C) 1983, 2014ORIGINAL BY THE STACK    UPDATES BY 4AM=======PRESS ANY KEY TO CONTINUE=======TRK: ..................................+.5:    0123456789ABCDEF0123456789ABCDEF012SC0: ..................................SC1: ..................................SC2: ..................................SC3: ..................................SC4: ..................................SC5: ..................................SC6: ..................................SC7: ..................................SC8: ..................................SC9: ..................................SCA: ..................................SCB: ..................................SCC: ..................................SCD: ..................................SCE: ..................................SCF: ..................................=======================================16SC $01,$00-$22,$0F BY1.0 S6,D1->S6,D2                 --^--]PR#5]CATALOG,S6,D2C1983 DSR^C#254093 FREE A 009 HELLO A 007 MENU A 013 EARTH SATELLITE A 007 STELLAR EVOLUTION A 019 MULTI-STAGE ROCKET A 011 TRANSFER ORBIT A 018 SPECTRAL TYPES A 021 STARSHIP A 014 BINARY STARS A 012 SOLAR SYSTEM B 034 PIC A 003 HREND A 010 SPIRAL GALAXY A 009 FREEZE-FRAME A 007 SINGLE EVOLUTION A 010 CLUSTER EVOLUTION T 013 EVOLDATA T 006 POLYDATA T 002 WAVELENGTHS T 005 LINESTRENGTHS A 010 JOVIAN MOONS A 017 SATELLITES A 010 ELLIPTICAL ORBIT A 031 BUILD-A-WORLD A 011 TEMPERATURE AND COLOR T 004 SSDATA A 012 INSIDE STARS A 016 COMETS T 004 SSLABELS A 010 INSIDESPT2 T 002 SSTEMP A 012 SSPT2 T 003 COMETDATA A 017 COMETSPT2 T 002 COMETTEMP A 008 SINGLEPT2 T 004 SINGLEDATA]RUN HELLO...works...Using Copy ][+, I can "copy DOS" from afreshly initialized DOS 3.3 disk ontothe non-working copy. This function ofCopy ][+ just sector-copies tracks 0-2from one disk to another, but it'seasier than setting that up manually insome other copy program.[S6,D1=demuffin'd copy with T01+][S6,D2=newly formatted DOS 3.3 disk]Copy ][+  --> COPY    --> DOS      --> from slot 6, drive 2      -->   to slot 6, drive 1...read read read......write write write...]PR#6...works...Quod erat liberandum.---------------------------------------A 4am crack                     No. 475------------------EOF------------------