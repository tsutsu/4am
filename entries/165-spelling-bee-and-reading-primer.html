<!doctype html>
<html><head>
<title>Spelling Bee and Reading Primer</title>
<link rel="Stylesheet" type="text/css" href="../site.css">
<meta name="viewport" content="width=420, initial-scale=1.0, user-scalable=no">
</head><body>

<p>Previous: <a rel="previous" href="./164-terrapin-logo-1-2.html">Terrapin Logo 1.2</a></p>
<section>

    <p>"Spelling Bee and Reading Primer" is a 1981 educational program by John R.</p>
    <p>Conrad and distributed by Edu-Ware.</p>
    <p class="seen">COPYA fails miserably and immediately. EDD 4 bit copy works, and the copy boots and runs without complaint. This tells me that there is some structural protection (i.e. data is stored on the disk in a non-standard way) but probably no secondary protection (e.g. an assembly language routine that executes during the boot process to determine whether it's booting from the original disk).</p>
    <p class="seen">The original disk appears to boot a modified DOS 3.3. Listening to the disk drive, it quickly moves out to track 2, then back to track 1, then track 0, then swings out to track $11 to read the disk catalog and load the startup program (HELLO or similar). You can hear a lot just by listening.</p>
    <p class="seen">Turning to my trusty Disk Fixer sector editor, I go to "Input/Output Control" (press "O") and set CHECKSUM ENABLED = NO. This option ignores checksum bytes and epilogue sequences -- as long as the address and data prologue are standard ("D5 AA 96" and "D5 AA AD", respectively), this will allow me to read each sector. And lo and behold, it works! I can read the data from every sector on every track.</p>
    <p class="seen">Given the (relatively) weak structural protection, I used to turn to the DOS</p>
    <p class="seen">3.3 master disk, patch the RWTS to ignore checksums and epilogue bytes (changing $B942 from "SEC" to "CLC"), and run COPYA. Then, one fine day, and completely by accident, I came across an original disk with a bad sector. I suppose this shouldn't surprise me.</p>
    <p class="seen">These floppies are decades old by now; it's amazing any of them work at all.</p>
    <p class="seen">The point is, I shouldn't be using tools that ignore potentially serious read errors. So no more COPYA+B942:18 patch. From now on, it's Super Demuffin or Advanced Demuffin to convert disks to a standard format. Let's see if AUTOTRACE can capture the RWTS from the original disk. If not, I'll have to resort to manual investigation.</p>
    <div class="curses_input">
      <code>[S6,D1=original disk]
[S5,D1=my work disk]</code>
    </div>
    <div class="line_editing">
      <code>]PR#5
...
CAPTURING BOOT0
...reboots slot 6...
...reboots slot 5...
SAVING BOOT0
CAPTURING BOOT1
...reboots slot 6...
...reboots slot 5...
SAVING BOOT1
SAVING RWTS
SAVING IOB</code>
    </div>
    <p class="seen">For those of you just tuning in, my work disk uses a custom program that I affectionately call "AUTOTRACE" to automate the process of boot tracing as far as possible. For some disks, this just captures track 0, sector 0 (saved in a file called "BOOT0") and stops.</p>
    <p class="seen">For other disks that load in the same way that an unprotected DOS 3.3 disk loads, it captures the next stage of the boot process as well (in a file called "BOOT1"). BOOT1 contains sectors 0-9 on track 0, which are loaded into memory at $B600..$BFFF. This generally contains the RWTS routines which the program uses to read the rest of the disk.</p>
    <p class="seen">If the RWTS is fairly normal as well (and my AUTOTRACE program just spot- checks a few memory locations to guess at its "normalcy"), there's a good chance I'll be able to use a tool called Advanced Demuffin (written in 1983 by The Stack) to convert the disk from whatever weird format it uses to store its sector data into a standard disk readable by unprotected DOS 3.3 disks or any other third-party tools.</p>
    <p class="seen">In this case, AUTOTRACE extracts the RWTS routines (generally loaded from track 0, sectors 2-9 into $B800..$BFFF) and saves *that* into a third file called "RWTS".</p>
    <p class="seen">If anything looks fishy or non- standard, AUTOTRACE just stops, and I have to check the files it saved so far to determine why. But in this case, it ran all the way through, automatically capturing BOOT0, BOOT1, and RWTS files.</p>
    <p class="seen">Now I can use Advanced Demuffin to convert the disk to a standard format. (It uses the disk's own RWTS to read the original, then a standard DOS 3.3- compatible RWTS to write out the data, sector by sector.)</p>
    <p class="seen">But wait, there's more! The latest feature I added to my AUTOTRACE program is automatic IOB module creation. What the heck is an IOB module? Well, the author of Advanced Demuffin anticipated that he couldn't anticipate everything, so he made the program extensible.</p>
    <p class="seen">Quoting from the Advanced Demuffin softdocs (included on my work disk):</p>
    <div class="curses">
      <code>An IOB module is an interface for the
source RWTS. Advanced Demuffin uses the
IOB module to set up the IOB table and
jump to RWTS.  The IOB module is stored
from $1400-$14FB. When Advanced
Demuffin loads in a IOB module, it
reads the first sector of the file off
the track-sector list and stores it at
$13FC-$14FB. When Advanced Demuffin
wants to read a sector it JSRs to the
IOB module with the phase number,
sector number, and the page number
stored in the A, Y and X registers
respectively. Since the source drive
always has to be drive one, Advanced
Demuffin can make the IOB module very
compact. After it gets the page,track
and sector Advanced Demuffin sets up
the IOB for RWTS using this infor-
mation, and JMPs to RWTS. (It jumps
instead of JSRing, because it lets the
RWTS do the RTS.) Here is a list of the
IOB module that is built in to Advanced
Demuffin:</code>
    </div>
    <div class="listing">
      <p class="comment">Convert phase # to track #</p>
      <code>1400-   4A          LSR</code>
      <p class="comment">Store track number</p>
      <code>1401-   8D 22 0F    STA   $0F22</code>
      <p class="comment">Store sector number</p>
      <code>1404-   8C 23 0F    STY   $0F23</code>
      <p class="comment">Store page number</p>
      <code>1407-   8E 27 0F    STX   $0F27</code>
      <code>140A-   A9 01       LDA   #$01</code>
      <p class="comment">Store the drive number</p>
      <code>140C-   8D 20 0F    STA   $0F20</code>
      <p class="comment">Store the read code</p>
      <code>140F-   8D 2A 0F    STA   $0F2A</code>
      <p class="comment">With high byte of IOB</p>
      <code>1412-   A9 0F       LDA   #$0F</code>
      <p class="comment">With low byte of IOB</p>
      <code>1414-   A0 1E       LDY   #$1E</code>
      <p class="comment">Goto RWTS</p>
      <code>1416-   4C 00 BD    JMP   $BD00</code>
    </div>
    <p class="seen">Basically, Advanced Demuffin only knows how to call a custom RWTS if it</p>
    <p class="seen">1. is loaded at $B800..$BFFF</p>
    <p class="seen">2. uses a standard RWTS parameter table</p>
    <p class="seen">3. has an entry point at $BD00 that</p>
    <p class="seen">takes the address of the parameter tables in A and Y</p>
    <p class="seen">4. doesn't require initialization</p>
    <p class="seen">As it turns out, that covers a *lot* of copy protected disks, but it doesn't cover this one because the RWTS on disk is loaded at $3800..$3FFF and has its entry point at $3D00. If I told</p>
    <p class="seen">Advanced Demuffin to load this RWTS at $B800 and call it at $BD00, it would crash quite spectacularly.</p>
    <p class="seen">So, I added a check to AUTOTRACE to detect that the RWTS is loaded in a non-standard location (lines 279-300 in the HELLO program on my work disk) and automatically create an IOB file that can tell Advanced Demuffin how to access it. Here's what it looks like:</p>
    <div class="line_editing">
      <code>]BLOAD IOB,A$1400
]CALL -151</code>
      <code>*1400L</code>
    </div>
    <div class="listing">
      <p class="comment">Most of this is identical to the standard IOB module that comes with</p>
      <p class="comment">Advanced Demuffin (explained above).</p>
      <code>1400-   4A          LSR
1401-   8D 22 0F    STA   $0F22
1404-   8C 23 0F    STY   $0F23
1407-   8E 27 0F    STX   $0F27
140A-   A9 01       LDA   #$01
140C-   8D 20 0F    STA   $0F20
140F-   8D 2A 0F    STA   $0F2A</code>
      <p class="comment">One problem with having an RWTS at $3800..$3FFF is that that range is normally used to store track data during the copy process. If we just let Advanced Demuffin run, it will overwrite the custom RWTS almost immediately and crash. In the ADVANCED DEMUFFIN TECH NOTES (also included on my work disk), the author mentions that you can control how many sectors Advanced Demuffin reads at a time, and where it puts it in memory. Normally $1CF0 is $20 and $1CF1 is $90, meaning that it will copy 7 tracks worth of data at a time into $2000..$8FFF. Changing the end parameter to $30 will only copy one track at a time, but has the distinct advantage of not overwriting the RWTS and crashing.</p>
      <code>1412-   A9 30       LDA   #$30
1414-   8D F1 1C    STA   $1CF1</code>
      <p class="comment">get the address of the RWTS parameter table at $0F1E and call the RWTS entry point at $3D00 (instead of the usual $BD00)</p>
      <code>1417-   A9 0F       LDA   #$0F
1419-   A0 1E       LDY   #$1E
141B-   4C 00 3D    JMP   $3D00</code>
    </div>
    <p class="seen">Now I can use Advanced Demuffin to convert the disk to a standard format.</p>
    <p class="seen">It uses the disk's own RWTS to read the original (stored in the RWTS file, accessed via the IOB module), then a standard DOS 3.3-compatible RWTS to write out the data, sector by sector.</p>
    <div class="curses_input">
      <code>[S6,D1=original disk]
[S6,D2=blank disk]
[S5,D1=my work disk]</code>
    </div>
    <div class="line_editing">
      <code>]PR#5
...</code>
      <code>]BRUN ADVANCED DEMUFFIN 1.5</code>
    </div>
    <div class="curses_input">
      <code>[press "5" to switch to slot 5]</code>
      <code>[press "R" to load a new RWTS module]
  --> At $B8, load "RWTS" from drive 1</code>
      <code>[press "I" to load a new IOB module]
  --> load "IOB" from drive 1</code>
      <code>[press "6" to switch to slot 6]</code>
      <code>[press "C" to convert disk]</code>
    </div>
    <p class="seen">This disk is 16 sectors, and the default options (copy the entire disk, all tracks, all sectors) don't need to be changed unless something goes horribly wrong.</p>
    <div class="terminal_output">
      <code>ADVANCED DEMUFFIN 1.5    (C) 1983, 2014
ORIGINAL BY THE STACK    UPDATES BY 4AM
=======PRESS ANY KEY TO CONTINUE=======
TRK:...................................
+.5:
    0123456789ABCDEF0123456789ABCDEF012
SC0:...................................
SC1:...................................
SC2:...................................
SC3:...................................
SC4:...................................
SC5:...................................
SC6:...................................
SC7:...................................
SC8:...................................
SC9:...................................
SCA:...................................
SCB:...................................
SCC:...................................
SCD:...................................
SCE:...................................
SCF:...................................
=======================================
16SC $00,$00-$22,$0F BY1.0 S6,D1->S6,D2</code>
    </div>
    <p class="seen">The disk's own RWTS gave no read errors on any track. This is the power and the genius of Advanced Demuffin. Every disk must be able to read itself. So, let it read itself, then capture the data and write it out in a standard format.</p>
    <div class="line_editing">
      <code>]PR#5
...</code>
      <code>]CATALOG,S6,D2</code>
    </div>
    <div class="terminal_output">
      <code>C1983 DSR^C#254
029 FREE</code>
    </div>
    <div class="line_editing">
      <code>*A 015 EDU-WARE
*B 025 EWS2
*I 006 APPLESOFT
*B 050 FPBASIC
*A 012 SPELLING BEE
*A 021 SP.SYSGEN
*T 008 FILE.STUDENT
*B 010 SPELL.CHARACTERS
*B 002 SPELL TUNES.OBJ
*B 004 SPELL.UTIL.OBJ0
*A 017 SP.1
*A 021 SP.2
*A 022 SP.3
*A 025 RP
*A 015 SP.ERROR
*B 007 DATA 1
*B 010 DATA 10
*B 007 DATA 11
*B 004 DATA 12
*B 016 DATA 13
*B 010 DATA 14
*B 012 DATA 15
*B 010 DATA 16
*B 012 DATA 17
*B 010 DATA 18
*B 012 DATA 19
*B 007 DATA 2
*B 011 DATA 20
*B 009 DATA 21
*B 010 DATA 22
*B 009 DATA 3
*B 010 DATA 4
*B 009 DATA 5
*B 007 DATA 6
*B 010 DATA 7
*B 012 DATA 8
*B 008 DATA 9
 T 002 SP.ERR</code>
    </div>
    <p>Hmm, no HELLO program, but EDU-WARE looks promising. (Ninja-edit from the future: Copy ][+ confirms that this is indeed the autostart program.)</p>
    <div class="line_editing">
      <code>]RUN EDU-WARE</code>
    </div>
    <p>Success! The program loads and runs without complaint. This tells me two things:</p>
    <p class="seen">1. The application doesn't have any</p>
    <p>runtime checks to ensure that it was booted from the original disk's custom DOS.</p>
    <p>2. It is using high-level DOS commands</p>
    <p>or the DOS vectors in page 3, since it works even after booting from my work disk running 64K Diversi-DOS.</p>
    <p class="seen">While that's excellent progress, I'm not quite done yet. Booting the demuffin'd disk directly just grinds endlessly, because it still has the original RWTS on it. That is, it still assumes that the data on the disk is stored in a non-standard format. But that's not true anymore, because</p>
    <p class="seen">Advanced Demuffin just normalized the disk format. So I need to patch the RWTS on my copy so it can read itself.</p>
    <p class="seen">A lot of disks need this sort of post- demuffin patching, and I got tired of doing it manually, so I wrote a program to do it for me. It is called, unsurprisingly, Post-Demuffin Patcher.</p>
    <p class="seen">It prompts you to select a slot and drive, then reads the demuffin'd disk, checks for a modified DOS 3.3-shaped RWTS, and applies the necessary patches so the disk can read itself. (It can also detect and bypass some nibble checks.) I've included a copy of Post-</p>
    <p class="seen">Demuffin Patcher on my work disk; the full source code is currently available at <https://archive.org/details/ PostDemuffinPatcher4am>.</p>
    <div class="curses_input">
      <code>[S6,D1=demuffin'd copy]</code>
    </div>
    <div class="line_editing">
      <code>]PR#5
...</code>
      <code>]BRUN PDP</code>
    </div>
    <p>T00,S03,$91 change DA to DE T00,S03,$35 change DA to DE</p>
    <p>This is the actual output of the program. Post-Demuffin Patcher prints out the changes it is going to make before it writes them to the disk. It looks like the epilogue bytes (normally "DE AA") were changed to "DA AA". PDP had no problem switching them back.</p>
    <div class="line_editing">
      <code>]PR#6</code>
    </div>
    <p class="seen">Success! The disk boots and runs with no complaint. There doesn't appear to be any further protection. Hooray for automation.</p>
    <p class="seen">Quod erat liberandum.</p>
</section>

<p>Next: <a rel="next" href="./166-racter.html">Racter</a></p>
</body></html>
