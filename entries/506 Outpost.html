<!doctype html>
<html><head>
<title>Outpost</title>
<link rel="Stylesheet" type="text/css" href="../site.css">
</head><body>

<section>
  <h2>Chapter 0</h2>
  <h3>In Which Various Automated Tools Fail In Interesting Ways</h3>

    <p class="seen">COPYA</p>
    <p class="seen">immediate disk read error</p>
    <p class="seen">Locksmith Fast Disk Backup</p>
    <p class="seen">unable to read any track</p>
    <p class="seen">EDD 4 bit copy (no sync, no count)</p>
    <p class="seen">hangs during boot</p>
    <p class="seen">Copy ][+ nibble editor</p>
    <p class="seen">track 0 has some 4-4 encoded data other tracks are unreadable</p>
    <p class="seen">Disk Fixer</p>
    <p class="seen">nope (can't read 4-4 encoded tracks)</p>
    <p class="seen">Why didn't COPYA work?</p>
    <p class="seen">not a 16-sector disk</p>
    <p class="seen">Why didn't Locksmith FDB work?</p>
    <p class="seen">ditto</p>
    <p class="seen">Why didn't my EDD copy work?</p>
    <p class="seen">I don't know. Could be a nibble check during boot. Could be that the data is loaded from half tracks. Could be both, or neither.</p>
    <p class="seen">Next steps:</p>
    <p class="seen">1. Trace the boot</p>
    <p class="seen">2. Capture the game in memory</p>
    <p>3. Write it out to a standard disk with some kind of fastloader</p>
</section>

<section>
  <h2>Chapter 1</h2>
  <h3>In Which We Find A Very Unfriendly "Do Not Disturb" Sign</h3>

    <div class="curses_input">
      <code>[S6,D1=original disk]
[S5,D1=my work disk]</code>
    </div>
    <div class="line_editing">
      <code>]PR#5
CAPTURING BOOT0
...reboots slot 6...
...reboots slot 5...
SAVING BOOT0</code>
      <code>]BLOAD BOOT0,A$800
]CALL -151</code>
      <code>*801L</code>
    </div>
    <div class="listing">
      <p class="comment">display hi-res graphics page (uninitialized)</p>
      <code>0801-   8D 50 C0    STA   $C050
0804-   8D 52 C0    STA   $C052
0807-   8D 54 C0    STA   $C054
080A-   8D 57 C0    STA   $C057</code>
      <p class="comment">get slot (x16)</p>
      <code>080D-   A6 2B       LDX   $2B</code>
      <p class="comment">a counter? or an address?</p>
      <code>080F-   A9 04       LDA   #$04
0811-   85 11       STA   $11
0813-   A0 00       LDY   #$00
0815-   84 10       STY   $10</code>
      <p class="comment">look for custom prologue ("DD AD DA")</p>
      <code>0817-   BD 8C C0    LDA   $C08C,X
081A-   10 FB       BPL   $0817
081C-   C9 DD       CMP   #$DD
081E-   D0 F7       BNE   $0817
0820-   BD 8C C0    LDA   $C08C,X
0823-   10 FB       BPL   $0820
0825-   C9 AD       CMP   #$AD
0827-   D0 F3       BNE   $081C
0829-   BD 8C C0    LDA   $C08C,X
082C-   10 FB       BPL   $0829
082E-   C9 DA       CMP   #$DA
0830-   D0 EA       BNE   $081C</code>
      <p class="comment">read 4-4 encoded data immediately (no address field, no sector numbers)</p>
      <code>0832-   BD 8C C0    LDA   $C08C,X
0835-   10 FB       BPL   $0832
0837-   38          SEC
0838-   2A          ROL
0839-   85 0E       STA   $0E
083B-   BD 8C C0    LDA   $C08C,X
083E-   10 FB       BPL   $083B
0840-   25 0E       AND   $0E</code>
      <p class="comment">($10) is an address, initialized at $080F as $0400 (yes, the text page)</p>
      <code>0842-   91 10       STA   ($10),Y
0844-   C8          INY
0845-   D0 EB       BNE   $0832
0847-   E6 11       INC   $11
0849-   A5 11       LDA   $11</code>
      <p class="comment">loop until we hit page 8 (i.e. we're filling $0400..$07FF)</p>
      <code>084B-   C9 08       CMP   #$08
084D-   D0 E3       BNE   $0832
084F-   BD 80 C0    LDA   $C080,X</code>
      <p class="comment">clear $0900..$BFFF in main memory</p>
      <code>0852-   A9 09       LDA   #$09
0854-   85 01       STA   $01
0856-   A9 00       LDA   #$00
0858-   85 00       STA   $00
085A-   A8          TAY
085B-   A2 B7       LDX   #$B7
085D-   91 00       STA   ($00),Y
085F-   C8          INY
0860-   D0 FB       BNE   $085D
0862-   E6 01       INC   $01
0864-   CA          DEX
0865-   D0 F6       BNE   $085D</code>
      <p class="comment">calculate a checksum of page 8 (this code right here)</p>
      <code>0867-   8A          TXA
0868-   E8          INX
0869-   F0 06       BEQ   $0871
086B-   5D 00 08    EOR   $0800,X
086E-   4C 68 08    JMP   $0868</code>
      <p class="comment">use the stack pointer (!) to keep a copy of that checksum</p>
      <code>0871-   AA          TAX
0872-   9A          TXS</code>
      <p class="comment">calculate another checksum of zero page</p>
      <code>0873-   A2 00       LDX   #$00
0875-   8A          TXA
0876-   55 00       EOR   $00,X
0878-   E8          INX
0879-   D0 FB       BNE   $0876</code>
      <p class="comment">get slot (x16) again</p>
      <code>087B-   A6 2B       LDX   $2B</code>
      <p class="comment">jump to the code we just read into the text page</p>
      <code>087D-   4C 00 04    JMP   $0400</code>
    </div>
    <p class="seen">Well that's lovely. I need to interrupt the boot at $087D, but if I do, it will modify the checksum that ends up in the stack pointer (which is a great place to stash a checksum as long as you never use PHA, PLA, PHP, PLP, JSR, RTS, or RTI).</p>
    <p class="seen">It's also wiping main memory, including the place I usually put my boot trace callbacks (around $9700).</p>
    <p class="seen">So, a three-pronged attack:</p>
    <p>1. Relocate the code to $0900. Most of</p>
    <p>it uses relative branching already, except for one JMP at $086E, which I can patch. The code will still run, but I'll be able to patch it without altering the checksum.</p>
    <p class="seen">2. Disable the memory wipe at $095D.</p>
    <p>3. Patch the code at $097D to jump to a</p>
    <p>routine under my control.</p>
</section>

<section>
  <h2>Chapter 2</h2>
  <h3>In Which Nothing Happens, Inhospitably</h3>

    <div class="line_editing">
      <code>*9600<C600.C6FFM</code>
    </div>
    <div class="listing">
      <p class="comment">relocate the code from $0800 to $0900</p>
      <code>96F8-   A0 00       LDY   #$00
96FA-   B9 00 08    LDA   $0800,Y
96FD-   99 00 09    STA   $0900,Y
9700-   C8          INY
9701-   D0 F7       BNE   $96FA</code>
      <p class="comment">disable the memory wipe by changing STA to BIT</p>
      <code>9703-   A9 24       LDA   #$24
9705-   8D 5D 09    STA   $095D</code>
      <p class="comment">fix the absolute JMP address</p>
      <code>9708-   A9 09       LDA   #$09
970A-   8D 70 09    STA   $0970</code>
      <p class="comment">set up the callback</p>
      <code>970D-   A9 1A       LDA   #$1A
970F-   8D 7E 09    STA   $097E
9712-   A9 97       LDA   #$97
9714-   8D 7F 09    STA   $097F</code>
      <p class="comment">start the boot</p>
      <code>9717-   4C 01 09    JMP   $0901</code>
      <p class="comment">callback is here copy the code on the text page to higher memory so it will survive a reboot</p>
      <code>971A-   A2 04       LDX   #$04
971C-   A0 00       LDY   #$00
971E-   B9 00 04    LDA   $0400,Y
9721-   99 00 24    STA   $2400,Y
9724-   C8          INY
9725-   D0 F7       BNE   $971E
9727-   EE 20 97    INC   $9720
972A-   EE 23 97    INC   $9723
972D-   CA          DEX
972E-   D0 EE       BNE   $971E</code>
      <p class="comment">turn off slot 6 drive motor and reboot to my work disk in slot 5</p>
      <code>9730-   AD E8 C0    LDA   $C0E8
9733-   4C 00 C5    JMP   $C500</code>
    </div>
    <div class="line_editing">
      <code>*BSAVE TRACE,A$9600,L$136
*9600G
...reboots slot 6...
...reboots slot 5...</code>
      <code>]BSAVE BOOT1 0400-07FF,A$2400,L$400
]CALL -151</code>
    </div>
    <p class="seen">I'm going to leave this code at $2400.</p>
    <p class="seen">Relative branches will look correct, but absolute addresses will be off by $2000.</p>
    <div class="line_editing">
      <code>*2400L</code>
    </div>
    <div class="listing">
      <p class="comment">calculate another checksum of zero page, starting with the value of the previous checksum (at $0873)</p>
      <code>2400-   A0 00       LDY   #$00
2402-   59 00 00    EOR   $0000,Y
2405-   C8          INY
2406-   D0 FA       BNE   $2402
2408-   A8          TAY</code>
      <p class="comment">if equal, nothing has changed (we've EOR'd everything twice, so we're back to zero)</p>
      <code>2409-   F0 03       BEQ   $240E</code>
      <p class="comment">if checksums don't match, jump to (what I presume is) The Badlands</p>
      <code>240B-   4C 74 07    JMP   $0774</code>
    </div>
    <div class="line_editing">
      <code>*2774L</code>
    </div>
    <div class="listing">
      <p class="comment">several entry points (also at $0770) for errors at different points in the boot process</p>
      <code>2774-   A9 01       LDA   #$01
2776-   D0 10       BNE   $2788
2778-   A9 02       LDA   #$02
277A-   D0 0C       BNE   $2788
277C-   A9 03       LDA   #$03
277E-   D0 08       BNE   $2788
2780-   A9 04       LDA   #$04
2782-   D0 04       BNE   $2788
2784-   A9 05       LDA   #$05
2786-   D0 00       BNE   $2788
2788-   09 B0       ORA   #$B0
278A-   2C 00 08    BIT   $0800
278D-   20 2F FB    JSR   $FB2F
2790-   AD 55 C0    LDA   $C055</code>
      <p class="comment">clear the rest of main memory, starting at $0801</p>
      <code>2793-   A9 08       LDA   #$08
2795-   85 01       STA   $01
2797-   A9 01       LDA   #$01
2799-   85 00       STA   $00
279B-   A0 00       LDY   #$00
279D-   A2 B8       LDX   #$B8
279F-   A9 A0       LDA   #$A0
27A1-   91 00       STA   ($00),Y
27A3-   C8          INY
27A4-   D0 FB       BNE   $27A1
27A6-   E6 01       INC   $01
27A8-   CA          DEX
27A9-   D0 F6       BNE   $27A1</code>
      <p class="comment">play a cute sound</p>
      <code>27AB-   A9 08       LDA   #$08
27AD-   85 00       STA   $00
27AF-   A0 80       LDY   #$80
27B1-   AD 30 C0    LDA   $C030
27B4-   A2 60       LDX   #$60
27B6-   CA          DEX
27B7-   D0 FD       BNE   $27B6
27B9-   88          DEY
27BA-   D0 F5       BNE   $27B1
27BC-   C6 00       DEC   $00
27BE-   D0 EF       BNE   $27AF</code>
      <p class="comment">and reboot from whence we came</p>
      <code>27C0-   A6 2B       LDX   $2B
27C2-   CA          DEX
27C3-   8A          TXA
27C4-   4A          LSR
27C5-   4A          LSR
27C6-   4A          LSR
27C7-   4A          LSR
27C8-   09 C0       ORA   #$C0
27CA-   48          PHA
27CB-   A9 FF       LDA   #$FF
27CD-   48          PHA
27CE-   60          RTS</code>
    </div>
    <p>Continuing from $040E...</p>
    <div class="line_editing">
      <code>*240EL</code>
    </div>
    <div class="listing">
      <p class="comment">set reset vector to The Badlands</p>
      <code>240E-   A9 70       LDA   #$70
2410-   8D F2 03    STA   $03F2
2413-   A9 07       LDA   #$07
2415-   8D F3 03    STA   $03F3
2418-   49 A5       EOR   #$A5
241A-   8D F4 03    STA   $03F4
241D-   86 2B       STX   $2B
241F-   EA          NOP</code>
      <p class="comment">read from ROM but write to RAM bank 2</p>
      <code>2420-   AD 81 C0    LDA   $C081
2423-   AD 81 C0    LDA   $C081</code>
      <p class="comment">wipe RAM bank 2 by copying ROM</p>
      <code>2426-   A0 00       LDY   #$00
2428-   84 00       STY   $00
242A-   A9 D0       LDA   #$D0
242C-   85 01       STA   $01
242E-   B1 00       LDA   ($00),Y
2430-   91 00       STA   ($00),Y
2432-   C8          INY
2433-   D0 F9       BNE   $242E
2435-   E6 01       INC   $01
2437-   D0 F5       BNE   $242E</code>
      <p class="comment">set low-level reset vector while the language card RAM is writeable (also to The Badlands)</p>
      <code>2439-   A9 70       LDA   #$70
243B-   8D FC FF    STA   $FFFC
243E-   A9 07       LDA   #$07
2440-   8D FD FF    STA   $FFFD</code>
      <p class="comment">switch back to ROM</p>
      <code>2443-   AD 80 C0    LDA   $C080</code>
      <p class="comment">set input and output vectors to</p>
      <p class="comment">The Badlands</p>
      <code>2446-   A9 74       LDA   #$74
2448-   85 36       STA   $36
244A-   85 38       STA   $38
244C-   A9 07       LDA   #$07
244E-   85 37       STA   $37
2450-   85 39       STA   $39</code>
      <p class="comment">take the checksum from boot0 (that we stashed in the stack pointer) and put it in zero page $0B</p>
      <code>2452-   A9 00       LDA   #$00
2454-   BA          TSX
2455-   86 0B       STX   $0B
2457-   85 0C       STA   $0C
2459-   85 0D       STA   $0D
245B-   85 0E       STA   $0E</code>
      <p class="comment">use that checksum (now in zero page $0B) as the starting value of ANOTHER checksum of all the code on the text page (including this code right here)</p>
      <code>245D-   A5 0B       LDA   $0B
245F-   A2 00       LDX   #$00
2461-   5D 00 04    EOR   $0400,X
2464-   5D 00 05    EOR   $0500,X
2467-   5D 00 06    EOR   $0600,X
246A-   5D 00 07    EOR   $0700,X
246D-   E8          INX
246E-   D0 F1       BNE   $2461</code>
      <p class="comment">push the new checksum to the stack, twice</p>
      <code>2470-   48          PHA
2471-   48          PHA</code>
    </div>
</section>

<section>
  <h2>Chapter 3</h2>
  <h3>You're Very Clever, Young Man, But It's Checksums All The Way Down</h3>

    <div class="line_editing">
      <code>*9600<C600.C6FFM</code>
    </div>
    <div class="listing">
      <p class="comment">move boot0 to $0900 and patch it up</p>
      <code>96F8-   A0 00       LDY   #$00
96FA-   B9 00 08    LDA   $0800,Y
96FD-   99 00 09    STA   $0900,Y
9700-   C8          INY
9701-   D0 F7       BNE   $96FA
9703-   A9 24       LDA   #$24
9705-   8D 5D 09    STA   $095D
9708-   A9 09       LDA   #$09
970A-   8D 70 09    STA   $0970</code>
      <p class="comment">set up callback after first checksum is calculated</p>
      <code>970D-   A9 1A       LDA   #$1A
970F-   8D 7E 09    STA   $097E
9712-   A9 97       LDA   #$97
9714-   8D 7F 09    STA   $097F</code>
      <p class="comment">start the boot</p>
      <code>9717-   4C 01 09    JMP   $0901</code>
      <p class="comment">callback is here save the checksum and unconditionally break to the monitor</p>
      <code>971A-   BA          TSX
971B-   8A          TXA
971C-   8D FF 97    STA   $97FF
971F-   AD E8 C0    LDA   $C0E8
9722-   4C 59 FF    JMP   $FF59</code>
    </div>
    <div class="line_editing">
      <code>*BSAVE TRACE 0872 CHECKSUM,A$9600,L$125
*9600G
...reboots slot 6...
<beep></code>
      <code>*97FF</code>
    </div>
    <div class="listing">
      <code>97FF- 20</code>
    </div>
    <p class="seen">The initial checksum of boot0 is $20.</p>
    <div class="line_editing">
      <code>*C500G
...
]CALL -151</code>
      <code>*9600<C600.C6FFM</code>
    </div>
    <div class="listing">
      <p class="comment">move boot0 to $0900 and patch it up</p>
      <code>96F8-   A0 00       LDY   #$00
96FA-   B9 00 08    LDA   $0800,Y
96FD-   99 00 09    STA   $0900,Y
9700-   C8          INY
9701-   D0 F7       BNE   $96FA
9703-   A9 24       LDA   #$24
9705-   8D 5D 09    STA   $095D
9708-   A9 09       LDA   #$09
970A-   8D 70 09    STA   $0970</code>
      <p class="comment">set up callback instead of jumping to boot1 at $0400</p>
      <code>970D-   A9 1A       LDA   #$1A
970F-   8D 7E 09    STA   $097E
9712-   A9 97       LDA   #$97
9714-   8D 7F 09    STA   $097F</code>
      <p class="comment">start the boot</p>
      <code>9717-   4C 01 09    JMP   $0901</code>
      <p class="comment">callback is here hard-code the initial checksum value ($20), then reproduce the checksum on the boot1 code before we start patching it to high heaven</p>
      <code>971A-   A2 20       LDX   #$20
971C-   A9 00       LDA   #$00
971E-   86 0B       STX   $0B
9720-   85 0C       STA   $0C
9722-   85 0D       STA   $0D
9724-   85 0E       STA   $0E
9726-   A5 0B       LDA   $0B
9728-   A2 00       LDX   #$00
972A-   5D 00 04    EOR   $0400,X
972D-   5D 00 05    EOR   $0500,X
9730-   5D 00 06    EOR   $0600,X
9733-   5D 00 07    EOR   $0700,X
9736-   E8          INX
9737-   D0 F1       BNE   $972A</code>
      <p class="comment">store the new checksum and break</p>
      <code>9739-   8D FF 97    STA   $97FF
973C-   AD E8 C0    LDA   $C0E8
973F-   4C 59 FF    JMP   $FF59</code>
    </div>
    <div class="line_editing">
      <code>*BSAVE TRACE 0470 CHECKSUM,A$960,L$142
*9600G
...reboots slot 6...
<beep></code>
      <code>*97FF</code>
    </div>
    <div class="listing">
      <code>97FF- 00</code>
    </div>
    <p>The second checksum, which gets pushed twice to the stack at $0470, is $00.</p>
</section>

<section>
  <h2>Chapter 4</h2>
  <h3>In Which Half A Track Is Better Than None</h3>

    <p class="seen">Continuing the boot trace at $0472...</p>
    <div class="line_editing">
      <code>*C500G
...
]BLOAD BOOT1 0400-07FF,A$2400
]CALL -151</code>
      <code>*2472L</code>
    </div>
    <div class="listing">
      <code>2472-   A0 03       LDY   #$03
2474-   20 00 05    JSR   $0500</code>
    </div>
    <div class="line_editing">
      <code>*2500L</code>
    </div>
    <div class="listing">
      <code>2500-   20 DC 04    JSR   $04DC</code>
    </div>
    <div class="line_editing">
      <code>*24DCL</code>
    </div>
    <div class="listing">
      <p class="comment">advance drive head by one phase (a.k.a. a half track)</p>
      <code>24DC-   E6 0C       INC   $0C
24DE-   A5 0C       LDA   $0C
24E0-   29 03       AND   #$03
24E2-   0A          ASL
24E3-   05 2B       ORA   $2B
24E5-   AA          TAX
24E6-   BD 81 C0    LDA   $C081,X
24E9-   20 F8 04    JSR   $04F8
24EC-   BD 80 C0    LDA   $C080,X
24EF-   20 F8 04    JSR   $04F8</code>
      <p class="comment">loop a number of times (given in the</p>
      <p class="comment">Y register on entry)</p>
      <code>24F2-   88          DEY
24F3-   D0 E7       BNE   $24DC
24F5-   A6 2B       LDX   $2B
24F7-   60          RTS
24F8-   8D 50 C0    STA   $C050
24FB-   A9 40       LDA   #$40
24FD-   4C A8 FC    JMP   $FCA8</code>
    </div>
    <p class="seen">We started on track 0 and advanced the drive head by 3 phases, so now we're on track 1.5.</p>
    <p>Continuing from $0503...</p>
    <div class="listing">
      <p class="comment">save X, display "Outpost" on hi-res screen (not shown), restore X</p>
      <code>2503-   86 2B       STX   $2B
2505-   A9 00       LDA   #$00
2507-   A2 0F       LDX   #$0F
2509-   A0 18       LDY   #$18
250B-   20 60 05    JSR   $0560
250E-   A6 2B       LDX   $2B
2510-   60          RTS</code>
    </div>
    <p>Continuing from $0477...</p>
    <div class="line_editing">
      <code>*2477L</code>
    </div>
    <div class="listing">
      <p class="comment">get target memory page from an array at $05F0</p>
      <code>2477-   A4 0E       LDY   $0E
2479-   B9 F0 05    LDA   $05F0,Y</code>
      <p class="comment">when page = 0, jump to next stage at $0520, otherwise continue at $0481</p>
      <code>247C-   D0 03       BNE   $2481
247E-   4C 20 05    JMP   $0520
2481-   20 90 04    JSR   $0490</code>
    </div>
    <div class="line_editing">
      <code>*2490L</code>
    </div>
    <div class="listing">
      <p class="comment">sector count (4-4 encoded tracks can only hold $0C pages worth of data)</p>
      <code>2490-   85 05       STA   $05
2492-   18          CLC
2493-   A9 0C       LDA   #$0C
2495-   85 06       STA   $06
2497-   A0 00       LDY   #$00
2499-   84 04       STY   $04</code>
      <p class="comment">custom prologue "DD AD DA"</p>
      <code>249B-   BD 8C C0    LDA   $C08C,X
249E-   10 FB       BPL   $249B
24A0-   C9 DD       CMP   #$DD
24A2-   D0 F7       BNE   $249B
24A4-   BD 8C C0    LDA   $C08C,X
24A7-   10 FB       BPL   $24A4
24A9-   C9 AD       CMP   #$AD
24AB-   D0 F3       BNE   $24A0
24AD-   BD 8C C0    LDA   $C08C,X
24B0-   10 FB       BPL   $24AD
24B2-   C9 DA       CMP   #$DA
24B4-   D0 EA       BNE   $24A0</code>
      <p class="comment">now read 4-4 encoded data into ($04)</p>
      <code>24B6-   BD 8C C0    LDA   $C08C,X
24B9-   10 FB       BPL   $24B6
24BB-   8D 57 C0    STA   $C057
24BE-   38          SEC
24BF-   2A          ROL
24C0-   8D 50 C0    STA   $C050
24C3-   85 0F       STA   $0F
24C5-   BD 8C C0    LDA   $C08C,X
24C8-   10 FB       BPL   $24C5
24CA-   25 0F       AND   $0F
24CC-   91 04       STA   ($04),Y
24CE-   C8          INY
24CF-   D0 E5       BNE   $24B6</code>
      <p class="comment">increment target page</p>
      <code>24D1-   E6 05       INC   $05</code>
      <p class="comment">decrement count</p>
      <code>24D3-   C6 06       DEC   $06</code>
      <p class="comment">Loop back to read more. Note: this goes directly to data read routine, not the prologue match routine. There is only one prologue per track.</p>
      <code>24D5-   D0 DF       BNE   $24B6
24D7-   60          RTS</code>
    </div>
    <p class="seen">Continuing from $0484...</p>
    <div class="line_editing">
      <code>*2484L</code>
    </div>
    <div class="listing">
      <p class="comment">sets Y=2 and falls through to drive head advance routine, so this will skip ahead 2 phases = 1 whole track, so we're still on half tracks but now</p>
      <p class="comment">2.5, 3.5, 4.5, &c.</p>
      <code>2484-   20 D8 04    JSR   $04D8</code>
      <p class="comment">show hi-res screen, increment index into page array, and jump back to read the next track</p>
      <code>2487-   8D 50 C0    STA   $C050
248A-   E6 0E       INC   $0E
248C-   4C 77 04    JMP   $0477</code>
    </div>
    <p class="seen">Here is the target page table (accessed at $0479):</p>
    <div class="line_editing">
      <code>*25F0.</code>
    </div>
    <div class="listing">
      <code>25F0- 08 14 40 4C 58 64 70 7C
25F8- 88 00</code>
    </div>
    <p>Each call to $0490 reads $0C sectors, so we're filling $0800..$1FFF, skipping hi-res screen 1 (initialized earlier with the graphical "Outpost" loading screen), then filling $4000..$93FF.</p>
    <p>Once the page array is exhausted, $047E jumps to $0520 for the next boot stage.</p>
    <p class="seen">To sum up:</p>
    <p>- We're reading data from consecutive half tracks (1.5, 2.5, 3.5, &c.) - Each track has $0C pages of data in a custom (non-sector-based) format - We're using $0800..$93FF in main memory (hi-res screen 1 was drawn earlier, then the rest is read directly from disk) - Nothing in this read loop relies on the checksum we stashed in the stack pointer or the later checksum we pushed twice to the stack - $047E exits via $0520</p>
    <p class="seen">Let's capture it.</p>
</section>

<section>
  <h2>Chapter 5</h2>
  <h3>In Which Things Have Been Made As Difficult As Possible For Us</h3>

    <div class="line_editing">
      <code>*9600<C600.C6FFM</code>
      <code>*96F8L</code>
    </div>
    <div class="listing">
      <p class="comment">move boot0 to $0900 and patch it up</p>
      <code>96F8-   A0 00       LDY   #$00
96FA-   B9 00 08    LDA   $0800,Y
96FD-   99 00 09    STA   $0900,Y
9700-   C8          INY
9701-   D0 F7       BNE   $96FA
9703-   A9 24       LDA   #$24
9705-   8D 5D 09    STA   $095D
9708-   A9 09       LDA   #$09
970A-   8D 70 09    STA   $0970</code>
      <p class="comment">set up callback before jumping to $0400</p>
      <code>970D-   A9 1A       LDA   #$1A
970F-   8D 7E 09    STA   $097E
9712-   A9 97       LDA   #$97
9714-   8D 7F 09    STA   $097F</code>
      <p class="comment">start the boot</p>
      <code>9717-   4C 01 09    JMP   $0901</code>
      <p class="comment">initialize zero page (copied verbatim from $0457)</p>
      <code>971A-   A9 00       LDA   #$00
971C-   85 0B       STA   $0B
971E-   85 0C       STA   $0C
9720-   85 0D       STA   $0D
9722-   85 0E       STA   $0E</code>
      <p class="comment">break to the monitor at $047E instead of continuing at $0520</p>
      <code>9724-   A9 4C       LDA   #$4C
9726-   8D 7E 04    STA   $047E
9729-   A9 59       LDA   #$59
972B-   8D 7F 04    STA   $047F
972E-   A9 FF       LDA   #$FF
9730-   8D 80 04    STA   $0480
9733-   4C 72 04    JMP   $0472</code>
    </div>
    <div class="line_editing">
      <code>*BSAVE TRACE2,A$9600,L$136</code>
      <p class="comment">fill main memory so I can verify which pages changed (in case I made a mistake in my analysis earlier!)</p>
      <code>*800:0 N 801<800.BEFEM</code>
      <code>*BRUN TRACE2
...reboots slot 6...
<beep></code>
    </div>
    <p>A quick inspection of memory confirms that $0800..$93FF have changed, and the rest are untouched (except the text page, but I knew that).</p>
    <p class="seen">According to "Inside the Apple //e" (pp. 296-8), $C311 copies data from main memory to aux memory and back. (Aux memory is what you get by having an 80-column card, 128K instead of 64.)</p>
    <p class="seen">The routine itself takes 4 parameters:</p>
    <div class="line_editing">
      <code>  ($3C/$3D) starting address
  ($3E/$3F) ending address
  ($42/$43) destination address in the
            other memory bank
  carry bit set for main->aux copy, or
            clear for aux->main copy</code>
    </div>
    <p>Thus, to copy $0800..$93FF to auxiliary memory:</p>
    <div class="listing">
      <code>0300-   A9 00       LDA   #$00
0302-   85 3C       STA   $3C
0304-   85 42       STA   $42
0306-   A9 08       LDA   #$08
0308-   85 3D       STA   $3D
030A-   85 43       STA   $43
030C-   A9 FF       LDA   #$FF
030E-   85 3E       STA   $3E
0310-   A9 93       LDA   #$93
0312-   85 3F       STA   $3F
0314-   38          SEC
0315-   4C 11 C3    JMP   $C311</code>
    </div>
    <div class="line_editing">
      <code>*300G</code>
      <p class="comment">reboot to my work disk</p>
      <code>*C500G
...
]CALL -151</code>
    </div>
    <p>And copy $0800..$93FF from auxiliary memory back to main memory, I only need to change the "SEC" to "CLC" at $0314:</p>
    <div class="listing">
      <code>0300-   A9 00       LDA   #$00
0302-   85 3C       STA   $3C
0304-   85 42       STA   $42
0306-   A9 08       LDA   #$08
0308-   85 3D       STA   $3D
030A-   85 43       STA   $43
030C-   A9 FF       LDA   #$FF
030E-   85 3E       STA   $3E
0310-   A9 93       LDA   #$93
0312-   85 3F       STA   $3F
0314-   18          CLC
0315-   4C 11 C3    JMP   $C311</code>
    </div>
    <div class="line_editing">
      <code>*300G</code>
      <code>*BSAVE OBJ,A$800,L$8C00</code>
    </div>
    <p>Continuing from $0520...</p>
    <div class="line_editing">
      <code>*BLOAD BOOT1 0400-07FF,A$2400
*2520L</code>
    </div>
    <div class="listing">
      <p class="comment">turn off drive motor</p>
      <code>2520-   BD 88 C0    LDA   $C088,X
2523-   20 D0 07    JSR   $07D0</code>
    </div>
    <div class="line_editing">
      <code>*27D0L</code>
    </div>
    <div class="listing">
      <p class="comment">calculate a simple one-byte checksum on the entire game code (minus hi-res graphics screen 1) to ensure the game code has not been tampered with</p>
      <code>27D0-   A0 00       LDY   #$00
27D2-   84 04       STY   $04
27D4-   A9 08       LDA   #$08
27D6-   85 05       STA   $05
27D8-   A9 00       LDA   #$00
27DA-   51 04       EOR   ($04),Y
27DC-   C8          INY
27DD-   D0 FB       BNE   $27DA
27DF-   E6 05       INC   $05
27E1-   A6 05       LDX   $05</code>
      <p class="comment">skip from $2000 to $4000</p>
      <code>27E3-   E0 20       CPX   #$20
27E5-   D0 F3       BNE   $27DA
27E7-   06 05       ASL   $05</code>
      <p class="comment">continue calculating checksum in the accumulator</p>
      <code>27E9-   51 04       EOR   ($04),Y
27EB-   C8          INY
27EC-   D0 FB       BNE   $27E9
27EE-   E6 05       INC   $05
27F0-   A6 05       LDX   $05
27F2-   E0 94       CPX   #$94
27F4-   D0 F3       BNE   $27E9
27F6-   A8          TAY</code>
      <p class="comment">if checksum fails, it's off to The</p>
      <p class="comment">Badlands with you!</p>
      <code>27F7-   D0 87       BNE   $2780
27F9-   60          RTS</code>
    </div>
    <p>Continuing from $0526...</p>
    <div class="line_editing">
      <code>*2526L</code>
    </div>
    <div class="listing">
      <p class="comment">get those checksum values we pushed to the stack at $0470 and start fiddling with them</p>
      <code>2526-   68          PLA          ;A=$00
2527-   AA          TAX          ;X=$00
2528-   68          PLA          ;A=$00
2529-   38          SEC
252A-   69 7E       ADC   #$7E   ;A=$7F
252C-   48          PHA          ;S+$7F
252D-   8A          TXA          ;A=$00
252E-   18          CLC
252F-   E9 00       SBC   #$00
2531-   48          PHA          ;S+$FF
2532-   38          SEC
2533-   69 36       ADC   #$36   ;A=$36
2535-   85 00       STA   $00
2537-   38          SEC
2538-   E9 36       SBC   #$36   ;A=$00
253A-   85 01       STA   $01</code>
    </div>
    <p>($00) points to $0036 now.</p>
    <div class="listing">
      <code>253C-   A8          TAY          ;Y=$00
253D-   68          PLA          ;A=$FF
253E-   48          PHA</code>
    </div>
    <p>Still $7F/$FF on the stack.</p>
    <div class="listing">
      <code>253F-   18          CLC
2540-   69 64       ADC   #$64   ;A=$63
2542-   91 00       STA   ($00),Y</code>
    </div>
    <p>zp$36 = $63 now.</p>
    <div class="listing">
      <code>2544-   C8          INY          ;Y=$01
2545-   38          SEC
2546-   69 00       ADC   #$00   ;A=$64
2548-   91 00       STA   ($00),Y</code>
    </div>
    <p>zp$37 = $64 now.</p>
    <div class="listing">
      <code>254A-   A9 00       LDA   #$00
254C-   85 00       STA   $00</code>
    </div>
    <p>($00) points to $0000 now.</p>
    <div class="listing">
      <code>254E-   68          PLA          ;A=$FF
254F-   48          PHA</code>
    </div>
    <p class="seen">Still $7F/$FF on the stack.</p>
    <div class="listing">
      <code>2550-   91 00       STA   ($00),Y</code>
    </div>
    <p>zp$00 = $FF now. ($00) points to $00FF.</p>
    <div class="listing">
      <code>2552-   C8          INY          ;Y=$01
2553-   38          SEC
2554-   E9 08       SBC   #$08   ;A=$F7
2556-   91 00       STA   ($00),Y</code>
    </div>
    <p>$0100 = $F7 now.</p>
    <p>($36) points to $6463. $0100 = $F7.</p>
    <p>The game starts at $8000.</p>
    <p>If I reproduce the initializations from this obfuscated routine at $0520, I should be able to run the game from the monitor. I need to do this all at once, since returning to the monitor will reset $36 and possibly $100 as well.</p>
    <div class="line_editing">
      <code>*36:63 64 N 100:F7 N 8000G
...crashes...</code>
    </div>
    <p>I'm missing something. Maybe a callback to the RWTS on the text page? I've seen other Sirius games do that.</p>
    <div class="line_editing">
      <code>*C500G
...
]CALL -151
*BLOAD OBJ
*BLOAD BOOT1 0400-07FF,A$9400
*36:63 64 N 100:F7 N 400<9400.97FFM N
 8000G
...crashes...</code>
    </div>
    <p>Still no luck. Maybe some secondary protection in the game code? Or even a secondary loader? (I've seen both in other Sirius games.)</p>
    <p>Sigh. Let's start tracing through the code at $8000.</p>
</section>

<section>
  <h2>Chapter 6</h2>
  <h3>And One More Thing</h3>

    <div class="line_editing">
      <code>*BLOAD OBJ
*8000L</code>
    </div>
    <div class="listing">
      <code>8000-   20 00 81    JSR   $8100</code>
    </div>
    <div class="line_editing">
      <code>*8100L</code>
    </div>
    <div class="listing">
      <p class="comment">harmless</p>
      <code>8100-   A9 C0       LDA   #$C0
8102-   85 45       STA   $45
8104-   A9 00       LDA   #$00
8106-   85 58       STA   $58
8108-   85 83       STA   $83
810A-   85 84       STA   $84
810C-   85 85       STA   $85
810E-   85 86       STA   $86
8110-   85 87       STA   $87
8112-   85 88       STA   $88
8114-   A9 01       LDA   #$01
8116-   85 8B       STA   $8B
8118-   85 60       STA   $60
811A-   4C 30 81    JMP   $8130</code>
    </div>
    <div class="line_editing">
      <code>*8130L</code>
    </div>
    <div class="listing">
      <p class="comment">harmless</p>
      <code>8130-   8D 3F 76    STA   $763F
8133-   A9 00       LDA   #$00
8135-   85 80       STA   $80
8137-   85 81       STA   $81
8139-   85 82       STA   $82
813B-   85 8C       STA   $8C
813D-   4C C0 8E    JMP   $8EC0</code>
    </div>
    <div class="line_editing">
      <code>*8EC0L</code>
    </div>
    <div class="listing">
      <p class="comment">hmm</p>
      <code>8EC0-   20 00 8F    JSR   $8F00
8EC3-   B0 0B       BCS   $8ED0
8EC5-   20 0B 8F    JSR   $8F0B
8EC8-   B0 06       BCS   $8ED0
8ECA-   4C 70 07    JMP   $0770
8ECD-   00          BRK
8ECE-   00          BRK
8ECF-   00          BRK
8ED0-   BD 88 C0    LDA   $C088,X
8ED3-   60          RTS</code>
    </div>
    <div class="line_editing">
      <code>*8F00L</code>
    </div>
    <div class="listing">
      <p class="comment">turn on boot slot drive motor (DEFINITELY NOT HARMLESS)</p>
      <code>8F00-   A6 2B       LDX   $2B
8F02-   BD 89 C0    LDA   $C089,X</code>
      <p class="comment">advance drive by 2 phases (=1 track)</p>
      <code>8F05-   A0 02       LDY   #$02
8F07-   20 DC 04    JSR   $04DC
8F0A-   EA          NOP
8F0B-   A9 00       LDA   #$00
8F0D-   85 01       STA   $01
8F0F-   A8          TAY</code>
      <p class="comment">look for prologue, "D5 AA AD"</p>
      <code>8F10-   BD 8C C0    LDA   $C08C,X
8F13-   10 FB       BPL   $8F10
8F15-   C9 D5       CMP   #$D5
8F17-   D0 F7       BNE   $8F10
8F19-   BD 8C C0    LDA   $C08C,X
8F1C-   10 FB       BPL   $8F19
8F1E-   C9 AA       CMP   #$AA
8F20-   D0 F3       BNE   $8F15
8F22-   BD 8C C0    LDA   $C08C,X
8F25-   10 FB       BPL   $8F22
8F27-   C9 AD       CMP   #$AD
8F29-   D0 EA       BNE   $8F15</code>
      <p class="comment">count nibbles until epilogue, "DE AA"</p>
      <code>8F2B-   C8          INY
8F2C-   D0 04       BNE   $8F32
8F2E-   E6 01       INC   $01
8F30-   F0 17       BEQ   $8F49
8F32-   BD 8C C0    LDA   $C08C,X
8F35-   10 F9       BPL   $8F30
8F37-   C9 DE       CMP   #$DE
8F39-   D0 F0       BNE   $8F2B
8F3B-   BD 8C C0    LDA   $C08C,X
8F3E-   10 F9       BPL   $8F39
8F40-   C9 AA       CMP   #$AA
8F42-   D0 E7       BNE   $8F2B</code>
      <p class="comment">if >= $0C00 nibbles between prologue and epilogue, carry is set on exit</p>
      <code>8F44-   A5 01       LDA   $01
8F46-   C9 0C       CMP   #$0C
8F48-   60          RTS
8F49-   38          SEC
8F4A-   60          RTS</code>
    </div>
    <p>Returning to $8EC0...</p>
    <div class="line_editing">
      <code>*8EC0L</code>
    </div>
    <div class="listing">
      <p class="comment">count nibbles</p>
      <code>8EC0-   20 00 8F    JSR   $8F00</code>
      <p class="comment">carry set = success, exit via $8ED0</p>
      <code>8EC3-   B0 0B       BCS   $8ED0</code>
      <p class="comment">count nibbles again (but stay on the same track)</p>
      <code>8EC5-   20 0B 8F    JSR   $8F0B</code>
      <p class="comment">carry set = success, exit via $8ED0</p>
      <code>8EC8-   B0 06       BCS   $8ED0</code>
      <p class="comment">failure --> The Badlands</p>
      <code>8ECA-   4C 70 07    JMP   $0770
8ECD-   00          BRK
8ECE-   00          BRK
8ECF-   00          BRK</code>
      <p class="comment">success path, turn off drive motor and return gracefully</p>
      <code>8ED0-   BD 88 C0    LDA   $C088,X
8ED3-   60          RTS</code>
    </div>
    <p>I should be able to put an "RTS" at $8EC0 to disable this secondary protection altogether.</p>
    <div class="line_editing">
      <code>*BLOAD BOOT1 0400-07FF,A$9400</code>
      <p class="comment">set $36/$37, $0100, copy RWTS to text page, disable secondary protection, and jump to the game entry point</p>
      <code>*36:63 64 N 100:F7 N 400<9400.97FFM N
 8EC0:60 N 8000G
...game works, and it is glorious...</code>
    </div>
    <p>I didn't bother setting zp$01 because the secondary protection overwrites it.</p>
    <p>The game doesn't appear to care about zp$01 is after it's checked at $8F46.</p>
    <p>It also doesn't seem to care about $00.</p>
    <p>However, I tried not setting $36/$37 and the graphics glitched out, so that vector is being used for something.</p>
    <p>I might be able to reduce this further, but $0400..$93FF is a nice round number (exactly 9 tracks on a 16-sector disk), so let's move on.</p>
</section>

<section>
  <h2>Chapter 7</h2>
  <h3>In Which We Step, Ever So Gently, Into The 21st Century</h3>

    <p class="seen">To reproduce the original disk's boot experience as faithfully as possible, I decided against releasing this as a file crack. The original disk displays the graphical title screen during boot.</p>
    <p>In fact, it *only* displays it during boot, then never again. Classic cracks often didn't include the title screen, because it was the 80s and 8192 bytes was expensive. The social mores of the classic crackers allowed for discarding title screens altogether in pursuit of the smallest possible file crack.</p>
    <p>I have all the game code. I know how to initialize it and call it. Now to write it all to disk. (We'll worry about reading it back in just a minute.)</p>
    <div class="curses_input">
      <code>[S6,D1=blank formatted disk]
[S5,D1=my work disk]</code>
    </div>
    <div class="line_editing">
      <code>]PR#5
...
]CALL -151</code>
    </div>
    <div class="listing">
      <p class="comment">page count (decremented)</p>
      <code>0300-   A9 90       LDA   #$90
0302-   85 FF       STA   $FF</code>
      <p class="comment">logical sector (incremented)</p>
      <code>0304-   A9 00       LDA   #$00
0306-   85 FE       STA   $FE</code>
      <p class="comment">call RWTS to write sector</p>
      <code>0308-   A9 03       LDA   #$03
030A-   A0 88       LDY   #$88
030C-   20 D9 03    JSR   $03D9</code>
      <p class="comment">increment logical sector, wrap around from $0F to $00 and increment track</p>
      <code>030F-   E6 FE       INC   $FE
0311-   A4 FE       LDY   $FE
0313-   C0 10       CPY   #$10
0315-   D0 07       BNE   $031E
0317-   A0 00       LDY   #$00
0319-   84 FE       STY   $FE
031B-   EE 8C 03    INC   $038C</code>
      <p class="comment">convert logical to physical sector</p>
      <code>031E-   B9 40 03    LDA   $0340,Y
0321-   8D 8D 03    STA   $038D</code>
      <p class="comment">increment page to write</p>
      <code>0324-   EE 91 03    INC   $0391</code>
      <p class="comment">loop until done with all $90 pages</p>
      <code>0327-   C6 FF       DEC   $FF
0329-   D0 DD       BNE   $0308
032B-   60          RTS</code>
    </div>
    <div class="line_editing">
      <code>*340.34F</code>
    </div>
    <div class="listing">
      <p class="comment">logical to physical sector mapping</p>
      <code>0340- 00 07 0E 06 0D 05 0C 04
0348- 0B 03 0A 02 09 01 08 0F</code>
    </div>
    <div class="line_editing">
      <code>*388.397</code>
    </div>
    <div class="listing">
      <p class="comment">RWTS parameter table, pre-initialized with slot 6, drive 1, track $01, sector $00, address $1400, and RWTS write command ($02)</p>
      <code>0388- 01 60 01 00 01 00 FB F7
0390- 00 14 00 00 02 00 00 60</code>
    </div>
    <div class="line_editing">
      <code>*BSAVE MAKE,A$300,L$98</code>
      <code>*BLOAD BOOT1 0400-07FF,A$1400
*BLOAD OBJ,A$1800</code>
      <code>*300G        ; write game to disk</code>
    </div>
    <p>Now I have the entire game on tracks $01-$09 of a standard 16-sector disk.</p>
    <p>To read it back as quickly as possible,</p>
    <p>I'll use qkumba's "0boot" bootloader.</p>
</section>

<section>
  <h2>Chapter 8</h2>
  <h3>0boot</h3>

    <p>0boot lives on track $00, just like me.</p>
    <p>Sector $00 (boot0) reuses the disk controller ROM routine to read sector $0E (boot1). Boot0 creates a few data tables, copys boot1 to zero page, modifies it to accomodate booting from any slot, and jumps to it.</p>
    <p>Boot0 is loaded at $0800 by the disk controller ROM routine.</p>
    <div class="listing">
      <p class="comment">tell the ROM to load only this sector (we'll do the rest manually)</p>
      <code>0800-  [01]</code>
      <p class="comment">The accumulator is $01 after loading sector $00, or $03 after loading sector $0E. We don't need to preserve the value, so we just shift the bits to determine whether this is the first or second time we've been here.</p>
      <code>0801-   4A          LSR</code>
      <p class="comment">second run -- we've loaded boot1, so skip to boot1 initialization routine</p>
      <code>0802-   D0 0E       BNE   $0812</code>
      <p class="comment">first run -- increment the physical sector to read (this will be the next sector under the drive head, so we'll waste as little time as possible waiting for the disk to spin)</p>
      <code>0804-   E6 3D       INC   $3D</code>
      <p class="comment">X holds the boot slot (x16) -- munge it into $Cx format (e.g. $C6 for slot 6, but we need to accomodate booting from any slot)</p>
      <code>0806-   8A          TXA
0807-   4A          LSR
0808-   4A          LSR
0809-   4A          LSR
080A-   4A          LSR
080B-   09 C0       ORA   #$C0</code>
      <p class="comment">push address (-1) of the sector read routine in the disk controller ROM</p>
      <code>080D-   48          PHA
080E-   A9 5B       LDA   #$5B
0810-   48          PHA</code>
      <p class="comment">"return" via disk controller ROM, which reads boot1 into $0900 and exits via $0801</p>
      <code>0811-   60          RTS</code>
      <p class="comment">Execution continues here (from $0802) after boot1 code has been loaded into $0900. This works around a bug in the CFFA 3000 firmware that doesn't guarantee that the Y register is always $00 at $0801, which is exactly the sort of bug that qkumba enjoys uncovering.</p>
      <code>0812-   A8          TAY</code>
      <p class="comment">munge the boot slot, e.g. $60 -> $EC (to be used later)</p>
      <code>0813-   8A          TXA
0814-   09 8C       ORA   #$8C</code>
      <p class="comment">Copy the boot1 code from $0901..$09FF to zero page. ($0900 holds the 0boot version number. This is version 1. $0000 is initialized later in boot1.)</p>
      <code>0816-   BE 00 09    LDX   $0900,Y
0819-   96 00       STX   $00,Y
081B-   C8          INY
081C-   D0 F8       BNE   $0816</code>
      <p class="comment">There are a number of places in boot1 that need to hit a slot-specific soft switch (read a nibble from disk, turn off the drive, &c). Rather than the usual form of "LDA $C08C,X", we will use "LDA $C0EC" and modify the $EC byte in advance, based on the boot slot. $00F5 is an array of all the places in the boot1 code that need this adjustment.</p>
      <code>081E-   C8          INY
081F-   B6 F5       LDX   $F5,Y
0821-   95 00       STA   $00,X
0823-   D0 F9       BNE   $081E</code>
      <p class="comment">munge $EC -> $E0 (used later to advance the drive head to the next track)</p>
      <code>0825-   29 F0       AND   #$F0
0827-   85 C8       STA   $C8</code>
      <p class="comment">munge $E0 -> $E8 (used later to turn off the drive motor)</p>
      <code>0829-   09 08       ORA   #$08
082B-   85 D6       STA   $D6</code>
      <p class="comment">push several addresses to the stack (more on this later)</p>
      <code>082D-   A2 06       LDX   #$06
082F-   B5 EF       LDA   $EF,X
0831-   48          PHA
0832-   CA          DEX
0833-   D0 FA       BNE   $082F</code>
      <p class="comment">number of tracks to load (x2) (game- specific -- this game uses 9 tracks)</p>
      <code>0835-   A0 12       LDY   #$12</code>
      <p class="comment">loop starts here</p>
      <code>083F-   8A          TXA</code>
      <p class="comment">every other time through this loop, we will end up taking this branch</p>
      <code>0840-   90 03       BCC   $0845</code>
      <p class="comment">X is 0 going into this loop, and it never changes, so A is always 0 too.</p>
      <p class="comment">So this will push $0000 to the stack (to "return" to $0001, which reads a track into memory)</p>
      <code>0842-   48          PHA
0843-   48          PHA</code>
      <p class="comment">There's a "SEC" hidden here (because it's opcode $38), but it's only executed if we take the branch at $0840, which lands at $0845, which is in the middle of this instruction.</p>
      <p class="comment">Otherwise we execute the compare, which clears the carry bit. So the carry flip-flops between set and clear, so the BCC at $0840 is only taken every other time.</p>
      <code>0844-   C9 38       CMP   #$38</code>
      <p class="comment">Push $00B3 to the stack, to "return" to $00B4. This routine advances the drive head to the next half track.</p>
      <code>0846-   48          PHA
0847-   A9 B3       LDA   #$B3
0849-   48          PHA</code>
      <p class="comment">loop until done</p>
      <code>084A-   88          DEY
084B-   D0 F2       BNE   $083F</code>
    </div>
    <p>Because of the carry flip-flop, we will push $00B3 to the stack every time through the loop, but we will only push $0000 every other time. The loop runs for twice the number of tracks we want to read, so the stack ends up looking like this:</p>
    <p>--top-- $00B3 (move drive 1/2 track) $00B3 (move drive another 1/2 track) $0000 (read track into memory) $00B3 \ $00B3 } second group $0000 / $00B3 \ $00B3 } third group $0000 / . . [repeated for each track] . $00B3 \ $00B3 } final group $0000 / $00D4 turn off drive, disable secondary protection $0525 game-specific entry point (pops next two values off the stack, sets up zero page, and pushes actual game entry point) $0000 boot1 checksum value (twice)</p>
    <p>--bottom--</p>
    <p>Boot1 reads the game into memory from tracks $01-$09, but it isn't a loop.</p>
    <p>It's one routine that reads a track and another routine that advances the drive head. We're essentially unrolling the read loop on the stack, in advance, so that each routine gets called as many times as we need, when we need it. Like dancers in a chorus line, each routine executes then cedes the spotlight. Each seems unaware of the others, but in reality they've all been meticulously choreographed.</p>
</section>

<section>
  <h2>Chapter 9</h2>
  <h3>6 + 2</h3>

    <p>Before I can explain the next chunk of code, I need to pause and explain a little bit of theory. As you probably know if you're the sort of person who reads this sort of thing, Apple II floppy disks do not contain the actual data that ends up being loaded into memory. Due to hardware limitations of the original Disk II drive, data on disk must be stored in an intermediate format called "nibbles." Bytes in memory are encoded into nibbles before writing to disk, and nibbles that you read from the disk must be decoded back into bytes. The round trip is lossless but requires some bit wrangling.</p>
    <p>Decoding nibbles-on-disk into bytes-in- memory is a multi-step process. In "6-and-2 encoding" (used by DOS 3.3, ProDOS, and all ".dsk" image files), there are 64 possible values that you may find in the data field (in the range $96..$FF, but not all of those, because some of them have bit patterns that trip up the drive firmware). We'll call these "raw nibbles."</p>
    <p>Step 1: read $156 raw nibbles from the data field. These values will range from $96 to $FF, but as mentioned earlier, not all values in that range will appear on disk.</p>
    <p>Now we have $156 raw nibbles.</p>
    <p>Step 2: decode each of the raw nibbles into a 6-bit byte between 0 and 63 (%00000000 and %00111111 in binary). $96 is the lowest valid raw nibble, so it gets decoded to 0. $97 is the next valid raw nibble, so it's decoded to 1. $98 and $99 are invalid, so we skip them, and $9A gets decoded to 2. And so on, up to $FF (the highest valid raw nibble), which gets decoded to 63.</p>
    <p>Now we have $156 6-bit bytes.</p>
    <p>Step 3: split up each of the first $56 6-bit bytes into pairs of bits. In other words, each 6-bit byte becomes three 2-bit bytes. These 2-bit bytes are merged with the next $100 6-bit bytes to create $100 8-bit bytes. Hence the name, "6-and-2" encoding.</p>
    <p>The exact process of how the bits are split and merged is... complicated. The first $56 6-bit bytes get split up into 2-bit bytes, but those two bits get swapped (so %01 becomes %10 and vice- versa). The other $100 6-bit bytes each get multiplied by 4 (a.k.a. bit-shifted two places left). This leaves a hole in the lower two bits, which is filled by one of the 2-bit bytes from the first group.</p>
    <p>A diagram might help. "a" through "x" each represent one bit.</p>
    <div class="terminal_output">
      <code>             -------------</code>
    </div>
    <p>1 decoded 3 decoded nibble in + nibbles in = 3 bytes first $56 other $100</p>
    <p>00abcdef 00ghijkl</p>
    <p>00mnopqr</p>
    <p>| 00stuvwx |</p>
    <p>split | & shifted</p>
    <p>swapped left x2</p>
    <p>| |</p>
    <p>V V</p>
    <p>000000fe + ghijkl00 = ghijklfe 000000dc + mnopqr00 = mnoprqdc 000000ba + stuvwx00 = stuvwxba</p>
    <div class="terminal_output">
      <code>             -------------</code>
    </div>
    <p>Tada! Four 6-bit bytes</p>
    <p>00abcdef 00ghijkl 00mnopqr 00stuvwx</p>
    <p>become three 8-bit bytes</p>
    <p>ghijklfe mnoprqdc stuvwxba</p>
    <p>When DOS 3.3 reads a sector, it reads the first $56 raw nibbles, decoded them into 6-bit bytes, and stashes them in a temporary buffer (at $BC00). Then it reads the other $100 raw nibbles, decodes them into 6-bit bytes, and puts them in another temporary buffer (at $BB00). Only then does DOS 3.3 start combining the bits from each group to create the full 8-bit bytes that will end up in the target page in memory.</p>
    <p>This is why DOS 3.3 "misses" sectors when it's reading, because it's busy twiddling bits while the disk is still spinning.</p>
</section>

<section>
  <h2>Chapter 10</h2>
  <h3>Back to 0boot</h3>

    <p>0boot also uses "6-and-2" encoding. The first $56 nibbles in the data field are still split into pairs of bits that need to be merged with nibbles that won't come until later. But instead of waiting for all $156 raw nibbles to be read from disk, it "interleaves" the nibble reads with the bit twiddling required to merge the first $56 6-bit bytes and the $100 that follow. By the time 0boot gets to the data field checksum, it has already stored all $100 8-bit bytes in their final resting place in memory. This means that 0boot can read all 16 sectors on a track in one revolution of the disk. That's crazy fast.</p>
    <p>To make it possible to do all the bit twiddling we need to do and not miss nibbles as the disk spins(*), we do some of the work earlier. We multiply each of the 64 possible decoded values by 4 and store those values. (Since this is accomplished by bit shifting and we're doing it before we start reading the disk, this is called the "pre-shift" table.) We also store all possible 2-bit values in a repeating pattern that will make it easy to look them up later. Then, as we're reading from disk (and timing is tight), we can simulate all the bit math we need to do with a series of table lookups. There is just enough time to convert each raw nibble into its final 8-bit byte before reading the next nibble.</p>
    <p>(*) The disk spins independently of the</p>
    <p>CPU, and we only have a limited time to read a nibble and do what we're going to do with it before WHOOPS HERE COMES ANOTHER ONE. So time is of the essence. Also, "As</p>
    <p>The Disk Spins" would make a great name for a retrocomputing-themed soap opera.</p>
    <p>The first table, at $0200..$02FF, is three columns wide and 64 rows deep.</p>
    <p>Astute readers will notice that 3 x 64 is not 256. Only three of the columns are used; the fourth (unused) column exists because multiplying by 3 is hard but multiplying by 4 is easy (in base 2 anyway). The three columns correspond to the three pairs of 2-bit values in those first $56 6-bit bytes. Since the values are only 2 bits wide, each column holds one of four different values (%00, %01, %10, or %11).</p>
    <p>The second table, at $0300..$0369, is the "pre-shift" table. This contains all the possible 6-bit bytes, in order, each multiplied by 4 (a.k.a. shifted to the left two places, so the 6 bits that started in columns 0-5 are now in columns 2-7, and columns 0 and 1 are zeroes). Like this:</p>
    <p>00ghijkl --> ghijkl00</p>
    <p>Astute readers will notice that there are only 64 possible 6-bit bytes, but this second table is larger than 64 bytes. To make lookups easier, the table has empty slots for each of the invalid raw nibbles. In other words, we don't do any math to decode raw nibbles into 6-bit bytes; we just look them up in this table (offset by $96, since that's the lowest valid raw nibble) and get the required bit shifting for free.</p>
    <p>addr | raw | decoded 6-bit | pre-shift -----+-----+----------------+---------- $300 | $96 | 0 = %00000000 | %00000000 $301 | $97 | 1 = %00000001 | %00000100 $302 | $98 [invalid raw nibble] $303 | $99 [invalid raw nibble] $304 | $9A | 2 = %00000010 | %00001000 $305 | $9B | 3 = %00000011 | %00001100 $306 | $9C [invalid raw nibble] $307 | $9D | 4 = %00000100 | %00010000</p>
    <p class="seen">. . .</p>
    <p>$368 | $FE | 62 = %00111110 | %11111000 $369 | $FF | 63 = %00111111 | %11111100</p>
    <p class="seen"></p>
    <p>Each value in this "pre-shift" table also serves as an index into the first table (with all the 2-bit bytes). This wasn't an accident; I mean, that sort of magic doesn't just happen. But the table of 2-bit bytes is arranged in such a way that we take one of the raw nibbles that needs to be decoded and split apart (from the first $56 raw nibbles in the data field), use that raw nibble as an index into the pre- shift table, then use that pre-shifted value as an index into the first table to get the 2-bit value we need. That's a neat trick.</p>
    <div class="listing">
      <p class="comment">this loop creates the pre-shift table at $300</p>
      <code>084D-   A2 40       LDX   #$40
084F-   A4 55       LDY   $55
0851-   98          TYA
0852-   0A          ASL
0853-   24 55       BIT   $55
0855-   F0 12       BEQ   $0869
0857-   05 55       ORA   $55
0859-   49 FF       EOR   #$FF
085B-   29 7E       AND   #$7E
085D-   B0 0A       BCS   $0869
085F-   4A          LSR
0860-   D0 FB       BNE   $085D
0862-   CA          DEX
0863-   8A          TXA
0864-   0A          ASL
0865-   0A          ASL
0866-   99 EA 02    STA   $02EA,Y
0869-   C6 55       DEC   $55
086B-   D0 E2       BNE   $084F</code>
    </div>
    <p>And this is the result (".." means the address is uninitialized and unused):</p>
    <div class="listing">
      <code>0300- 00 04 .. .. 08 0C .. 10
0308- 14 18 .. .. .. .. .. ..
0310- 1C 20 .. .. .. 24 28 2C
0318- 30 34 .. .. 38 3C 40 44
0320- 48 4C .. 50 54 58 5C 60
0328- 64 68 .. .. .. .. .. ..
0330- .. .. .. .. .. 6C .. 70
0338- 74 78 .. .. .. 7C .. ..
0340- 80 84 .. 88 8C 90 94 98
0348- 9C A0 .. .. .. .. .. A4
0350- A8 AC .. B0 B4 B8 BC C0
0358- C4 C8 .. .. CC D0 D4 D8
0360- DC E0 .. E4 E8 EC F0 F4
0368- F8 FC</code>
      <p class="comment">this loop creates the table of 2-bit values at $200, magically arranged to enable easy lookups later</p>
      <code>086D-   46 B7       LSR   $B7
086F-   46 B7       LSR   $B7
0871-   B5 FC       LDA   $FC,X
0873-   99 FF 01    STA   $01FF,Y
0876-   E6 AC       INC   $AC
0878-   A5 AC       LDA   $AC
087A-   25 B7       AND   $B7
087C-   D0 05       BNE   $0883
087E-   E8          INX
087F-   8A          TXA
0880-   29 03       AND   #$03
0882-   AA          TAX
0883-   C8          INY
0884-   C8          INY
0885-   C8          INY
0886-   C8          INY
0887-   C0 04       CPY   #$04
0889-   B0 E6       BCS   $0871
088B-   C8          INY
088C-   C0 04       CPY   #$04
088E-   90 DD       BCC   $086D</code>
    </div>
    <p>And this is the result:</p>
    <div class="listing">
      <code>0200- 00 00 00 .. 00 00 02 ..
0208- 00 00 01 .. 00 00 03 ..
0210- 00 02 00 .. 00 02 02 ..
0218- 00 02 01 .. 00 02 03 ..
0220- 00 01 00 .. 00 01 02 ..
0228- 00 01 01 .. 00 01 03 ..
0230- 00 03 00 .. 00 03 02 ..
0238- 00 03 01 .. 00 03 03 ..
0240- 02 00 00 .. 02 00 02 ..
0248- 02 00 01 .. 02 00 03 ..
0250- 02 02 00 .. 02 02 02 ..
0258- 02 02 01 .. 02 02 03 ..
0260- 02 01 00 .. 02 01 02 ..
0268- 02 01 01 .. 02 01 03 ..
0270- 02 03 00 .. 02 03 02 ..
0278- 02 03 01 .. 02 03 03 ..
0280- 01 00 00 .. 01 00 02 ..
0288- 01 00 01 .. 01 00 03 ..
0290- 01 02 00 .. 01 02 02 ..
0298- 01 02 01 .. 01 02 03 ..
02A0- 01 01 00 .. 01 01 02 ..
02A8- 01 01 01 .. 01 01 03 ..
02B0- 01 03 00 .. 01 03 02 ..
02B8- 01 03 01 .. 01 03 03 ..
02C0- 03 00 00 .. 03 00 02 ..
02C8- 03 00 01 .. 03 00 03 ..
02D0- 03 02 00 .. 03 02 02 ..
02D8- 03 02 01 .. 03 02 03 ..
02E0- 03 01 00 .. 03 01 02 ..
02E8- 03 01 01 .. 03 01 03 ..
02F0- 03 03 00 .. 03 03 02 ..
02F8- 03 03 01 .. 03 03 03 ..</code>
    </div>
    <p>And now for something completely different. The original disk briefly displayed an uninitialized hi-res graphics page (originally at $0801 -- literally the first thing it does on boot). So I want to do the same. It won't be absolutely first thing, but it'll be close.</p>
    <div class="listing">
      <code>0890-   2C 54 C0    BIT   $C054
0893-   2C 52 C0    BIT   $C052
0896-   2C 57 C0    BIT   $C057
0899-   2C 50 C0    BIT   $C050
089C-   60          RTS</code>
    </div>
    <div class="curses_input">
      <code>[Note to future self: $0890..$08FD is
 available for game-specific init code,
 but it can't rely on or disturb zero
 page in any way. That rules out a lot
 of built-in ROM routines; be careful.
 If the game needs no initialization,
 you can zap this entire range and put
 an "RTS" at $0890.]</code>
    </div>
    <p>Everything else is already lined up on the stack. All that's left to do is "return" and let the stack guide us through the rest of the boot.</p>
</section>

<section>
  <h2>Chapter 11</h2>
  <h3>0boot boot1</h3>

    <p>The rest of the boot runs from zero page. It's hard to show you exactly what boot1 will look like, because it relies heavily on self-modifying code.</p>
    <p>In a standard DOS 3.3 RWTS, the softswitch to read the data latch is "LDA $C08C,X", where X is the boot slot times 16 (to allow disks to boot from any slot). 0boot also supports booting from any slot, but instead of using an index, each fetch instruction is pre- set based on the boot slot. Not only does this free up the X register, it lets us juggle all the registers and put the raw nibble value in whichever one is convenient at the time. (We take full advantage of this freedom.) I've marked each pre-set softswitch with "o_O" to remind you that self-modifying code is awesome.</p>
    <p>There are several other instances of addresses and constants that get modified while boot1 is running. I've marked these with "/!\" to remind you that self-modifying code is dangerous and you should not try this at home.</p>
    <p>The first thing popped off the stack is the drive arm move routine at $00B4. It moves the drive exactly one phase (half a track).</p>
    <div class="listing">
      <code>00B4-   E6 B7       INC   $B7</code>
      <p class="comment">This value was set at $00B4 (above).</p>
      <p class="comment">It's incremented monotonically, but it's ANDed with $03 later, so its exact value isn't relevant.</p>
      <code>00B6-   A0 00       LDY   #$00      /!\</code>
      <p class="comment">short wait for PHASEON</p>
      <code>00B8-   A9 04       LDA   #$04
00BA-   20 C0 00    JSR   $00C0</code>
      <p class="comment">fall through</p>
      <code>00BD-   88          DEY</code>
      <p class="comment">longer wait for PHASEOFF</p>
      <code>00BE-   69 41       ADC   #$41
00C0-   85 CB       STA   $CB</code>
      <p class="comment">calculate the proper stepper motor to access</p>
      <code>00C2-   98          TYA
00C3-   29 03       AND   #$03
00C5-   2A          ROL
00C6-   AA          TAX</code>
      <p class="comment">This address was set at $0827, based on the boot slot.</p>
      <code>00C7-   BD E0 C0    LDA   $C0E0,X   /!\</code>
      <p class="comment">This value was set at $00C0 so that PHASEON and PHASEOFF have optimal wait times.</p>
      <code>00CA-   A9 D1       LDA   #$D1      /!\</code>
      <p class="comment">wait exactly the right amount of time after accessing the proper stepper motor</p>
      <code>00CC-   4C A8 FC    JMP   $FCA8</code>
    </div>
    <p>Since the drive arm routine only moves one phase, it was pushed to the stack twice before each track read. Our game is stored on whole tracks; this half- track trickery is only to save a few bytes of code in boot1.</p>
    <p>The track read routine starts at $0001, because that let us save 1 byte in the boot0 code when we were pushing addresses to the stack. (We could just push $00 twice.)</p>
    <div class="listing">
      <p class="comment">sectors-left-to-read-on-this-track counter (incremented to $00)</p>
      <code>0001-   A2 F0       LDX   #$F0
0003-   86 00       STX   $00</code>
    </div>
    <p>We initialize an array at $00F0 that tracks which sectors we've read from the current track. Astute readers will notice that this part of zero page had real data in it -- some addresses that were pushed to the stack, and some other values that were used to create the 2-bit table at $0200. All true, but all those operations are now complete, and the space from $00F0..$00FF is now available for unrelated uses.</p>
    <p>The array is in physical sector order, thus the RWTS assumes data is stored in physical sector order on each track. (This is why my MAKE program had to map to physical sector order when writing.</p>
    <p>This saves 18 bytes: 16 for the table and 2 for the lookup command!) Values are the actual pages in memory where that sector should go, and they get zeroed once the sector is read (so we don't waste time decoding the same sector twice).</p>
    <div class="listing">
      <p class="comment">starting address (game-specific; this one starts loading at $0400)</p>
      <code>0005-   A9 04       LDA   #$04      /!\
0007-   95 00       STA   $00,X
0009-   E6 06       INC   $06
000B-   E8          INX
000C-   D0 F7       BNE   $0005</code>
      <code>000E-   20 CF 00    JSR   $00CF</code>
      <p class="comment">subroutine reads a nibble and stores it in the accumulator</p>
      <code>00CF-   AD EC C0    LDA   $C0EC     o_O
00D2-   10 FB       BPL   $00CF
00D4-   60          RTS</code>
    </div>
    <p>Continuing from $0011...</p>
    <div class="listing">
      <p class="comment">first nibble must be $D5</p>
      <code>0011-   C9 D5       CMP   #$D5
0013-   D0 F9       BNE   $000E</code>
      <p class="comment">read second nibble, must be $AA</p>
      <code>0015-   20 CF 00    JSR   $00CF
0018-   C9 AA       CMP   #$AA
001A-   D0 F5       BNE   $0011</code>
      <p class="comment">We actually need the Y register to be $AA for unrelated reasons later, so let's set that now. (We have time, and it saves 1 byte!)</p>
      <code>001C-   A8          TAY</code>
      <p class="comment">read the third nibble</p>
      <code>001D-   20 CF 00    JSR   $00CF</code>
      <p class="comment">is it $AD?</p>
      <code>0020-   49 AD       EOR   #$AD</code>
      <p class="comment">Yes, which means this is the data prologue. Branch forward to start reading the data field.</p>
      <code>0022-   F0 1F       BEQ   $0043</code>
    </div>
    <p>If that third nibble is not $AD, we assume it's the end of the address prologue. ($96 would be the third nibble of a standard address prologue, but we don't actually check.) We fall through and start decoding the 4-4 encoded values in the address field.</p>
    <div class="listing">
      <code>0024-   A0 02       LDY   #$02</code>
    </div>
    <p>The first time through this loop, we'll read the disk volume number.</p>
    <p>The second time, we'll read the track number. The third time, we'll read the physical sector number. We don't actually care about the disk volume or the track number, and once we get the sector number, we don't verify the address field checksum.</p>
    <div class="listing">
      <code>0026-   20 CF 00    JSR   $00CF
0029-   2A          ROL
002A-   85 AC       STA   $AC
002C-   20 CF 00    JSR   $00CF
002F-   25 AC       AND   $AC
0031-   88          DEY
0032-   10 F2       BPL   $0026</code>
      <p class="comment">store the physical sector number (will re-use later)</p>
      <code>0034-   85 AC       STA   $AC</code>
      <p class="comment">use physical sector number as an index into the sector address array</p>
      <code>0036-   A8          TAY</code>
      <p class="comment">get the target page (where we want to store this sector in memory)</p>
      <code>0037-   B6 F0       LDX   $F0,Y</code>
      <p class="comment">store the target page in several places throughout the following code</p>
      <code>0039-   86 9B       STX   $9B
003B-   CA          DEX
003C-   86 6B       STX   $6B
003E-   86 83       STX   $83
0040-   E8          INX</code>
      <p class="comment">This is an unconditional branch, because the ROL at $0029 will always set the carry. We're done processing the address field, so we need to loop back and wait for the data prologue.</p>
      <code>0041-   B0 CB       BCS   $000E</code>
      <p class="comment">execution continues here (from $0022) after matching the data prologue</p>
      <code>0043-   E0 00       CPX   #$00</code>
      <p class="comment">If X is still $00, it means we found a data prologue before we found an address prologue. In that case, we have to skip this sector, because we don't know which sector it is and we wouldn't know where to put it.</p>
      <code>0045-   F0 C7       BEQ   $000E</code>
    </div>
    <p>Nibble loop #1 reads nibbles $00..$55, looks up the corresponding offset in the preshift table at $0300, and stores that offset in the temporary buffer at $036A.</p>
    <div class="listing">
      <p class="comment">initialize rolling checksum to $00</p>
      <code>0047-   85 55       STA   $55
0049-   AE EC C0    LDX   $C0EC      o_O
004C-   10 FB       BPL   $0049</code>
      <p class="comment">The nibble value is in the X register now. The lowest possible nibble value is $96 and the highest is $FF. To look up the offset in the table at $0300, we need to subtract $96 from $0300 and add X.</p>
      <code>004E-   BD 6A 02    LDA   $026A,X</code>
      <p class="comment">Now the accumulator has the offset into the table of individual 2-bit combinations ($0200..$02FF). Store that offset in the temporary buffer at $036A, in the order we read the nibbles. But the Y register started counting at $AA, so we need to subtract $AA from $036A and add Y.</p>
      <code>0051-   99 C0 02    STA   $02C0,Y</code>
      <p class="comment">The EOR value is set at $0047 each time through loop #1.</p>
      <code>0054-   49 00       EOR   #$00      /!\
0056-   C8          INY
0057-   D0 EE       BNE   $0047</code>
    </div>
    <p>Here endeth nibble loop #1.</p>
    <p>Nibble loop #2 reads nibbles $56..$AB, combines them with bits 0-1 of the appropriate nibble from the first $56, and stores them in bytes $00..$55 of the target page in memory.</p>
    <div class="listing">
      <code>0059-   A0 AA       LDY   #$AA
005B-   AE EC C0    LDX   $C0EC     o_O
005E-   10 FB       BPL   $005B
0060-   5D 6A 02    EOR   $026A,X
0063-   BE C0 02    LDX   $02C0,Y
0066-   5D 02 02    EOR   $0202,X</code>
      <p class="comment">This address was set at $003C based on the target page (minus 1 so we can add Y from $AA..$FF).</p>
      <code>0069-   99 56 D1    STA   $D156,Y   /!\
006C-   C8          INY
006D-   D0 EC       BNE   $005B</code>
    </div>
    <p>Here endeth nibble loop #2.</p>
    <p>Nibble loop #3 reads nibbles $AC..$101, combines them with bits 2-3 of the appropriate nibble from the first $56, and stores them in bytes $56..$AB of the target page in memory.</p>
    <div class="listing">
      <code>006F-   29 FC       AND   #$FC
0071-   A0 AA       LDY   #$AA
0073-   AE EC C0    LDX   $C0EC     o_O
0076-   10 FB       BPL   $0073
0078-   5D 6A 02    EOR   $026A,X
007B-   BE C0 02    LDX   $02C0,Y
007E-   5D 01 02    EOR   $0201,X</code>
      <p class="comment">This address was set at $003E based on the target page (minus 1 so we can add Y from $AA..$FF).</p>
      <code>0081-   99 AC D1    STA   $D1AC,Y   /!\
0084-   C8          INY
0085-   D0 EC       BNE   $0073</code>
    </div>
    <p>Here endeth nibble loop #3.</p>
    <p>Loop #4 reads nibbles $102..$155, combines them with bits 4-5 of the appropriate nibble from the first $56, and stores them in bytes $AC..$FF of the target page in memory.</p>
    <div class="listing">
      <code>0087-   29 FC       AND   #$FC
0089-   A2 AC       LDX   #$AC
008B-   AC EC C0    LDY   $C0EC     o_O
008E-   10 FB       BPL   $008B
0090-   59 6A 02    EOR   $026A,Y
0093-   BC BE 02    LDY   $02BE,X
0096-   59 00 02    EOR   $0200,Y</code>
      <p class="comment">This address was set at $0039 based on the target page.</p>
      <code>0099-   9D 00 D1    STA   $D100,X   /!\
009C-   E8          INX
009D-   D0 EC       BNE   $008B</code>
    </div>
    <p>Here endeth nibble loop #4.</p>
    <div class="listing">
      <p class="comment">Finally, get the last nibble, which is the checksum of all the previous nibbles.</p>
      <code>009F-   29 FC       AND   #$FC
00A1-   AC EC C0    LDY   $C0EC     o_O
00A4-   10 FB       BPL   $00A1
00A6-   59 6A 02    EOR   $026A,Y</code>
      <p class="comment">if checksum fails, start over</p>
      <code>00A9-   D0 96       BNE   $0041</code>
      <p class="comment">This was set to the physical sector number (at $0034), so this is a index into the 16- byte array at $00F0.</p>
      <code>00AB-   A0 C0       LDY   #$C0      /!\</code>
      <p class="comment">store $00 at this index in the sector array to indicate that we've read this sector</p>
      <code>00AD-   96 F0       STX   $F0,Y</code>
      <p class="comment">are we done yet?</p>
      <code>00AF-   E6 00       INC   $00</code>
      <p class="comment">nope, loop back to read more sectors</p>
      <code>00B1-   D0 8E       BNE   $0041</code>
      <p class="comment">And that's all she read.</p>
      <code>00B3-   60          RTS</code>
    </div>
    <p>0boot's track read routine is done when $0000 hits $00, which is astonishingly beautiful. Like, "now I know God" level of beauty.</p>
    <p>And so it goes: we pop another address off the stack, move the drive arm, read another track, and eventually pop off the final routine at $00D5:</p>
    <div class="listing">
      <p class="comment">turn off drive motor</p>
      <code>00D5-   AD E8 C0    LDA   $C0E8     /!\</code>
      <p class="comment">disable secondary protection</p>
      <code>00D8-   A9 60       LDA   #$60
00DA-   8D C0 8E    STA   $8EC0
00DD-   60          RTS</code>
    </div>
    <p>The "RTS" at $DD will pop the next address off the stack ($05/$25) and continue at $0526. As we saw earlier, that routine immediately pops the next two values off the stack and uses them to set up $00/$01, $36/$37, $0100, and jump to the game's entry point ($8000).</p>
    <p>But we don't need to do any of that ourselves. We just need to prepare the stack, then the original code can do what it's designed to do.</p>
    <p>Minus the protect-y bits, of course.</p>
    <p class="seen">Quod erat liberandum.</p>
</section>

</body></html>
